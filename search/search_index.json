{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>The logo is generated by WOMBO Dream</p>"},{"location":"#overview","title":"Overview","text":"<p>Bunnet - is a Python object-document mapper (ODM) for MongoDB. It is a synchronous fork of Beanie ODM.</p> <p>When using Bunnet each database collection has a corresponding <code>Document</code> that is used to interact with that collection. In addition to retrieving data, Bunnet allows you to add, update, or delete documents from the collection as well.</p> <p>Bunnet saves you time by removing boilerplate code, and it helps you focus on the parts of your app that actually matter.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#pip","title":"PIP","text":"<pre><code>pip install bunnet\n</code></pre>"},{"location":"#poetry","title":"Poetry","text":"<pre><code>poetry add bunnet\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from typing import Optional\n\nfrom pymongo import MongoClient\nfrom pydantic import BaseModel\n\nfrom bunnet import Document, Indexed, init_bunnet\n\n\nclass Category(BaseModel):\n    name: str\n    description: str\n\n\nclass Product(Document):\n    name: str                          # You can use normal types just like in pydantic\n    description: Optional[str] = None\n    price: Indexed(float)              # You can also specify that a field should correspond to an index\n    category: Category                 # You can include pydantic models as well\n\n\n\n# Bunnet uses Pymongo client under the hood \nclient = MongoClient(\"mongodb://user:pass@host:27017\")\n\n# Initialize bunnet with the Product document class\ninit_bunnet(database=client.db_name, document_models=[Product])\n\nchocolate = Category(name=\"Chocolate\", description=\"A preparation of roasted and ground cacao seeds.\")\n# Bunnet documents work just like pydantic models\ntonybar = Product(name=\"Tony's\", price=5.95, category=chocolate)\n# And can be inserted into the database\ntonybar.insert() \n\n# You can find documents with pythonic syntax\nproduct = Product.find_one(Product.price &lt; 10).run()\n\n# And update them\nproduct.set({Product.name:\"Gold bar\"})\n</code></pre>"},{"location":"#links","title":"Links","text":""},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Doc - Tutorial, API documentation, and development guidelines.</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>GitHub - GitHub page of the   project</li> <li>Changelog - list of all   the valuable changes</li> <li>Discord - ask your questions, share   ideas or just say <code>Hello!!</code></li> </ul> <p>Supported by JetBrains</p> <p></p>"},{"location":"changelog/","title":"Changelog","text":"<p>Bunnet project</p>"},{"location":"changelog/#130-2023-10-14","title":"1.3.0 - 2023-10-14","text":""},{"location":"changelog/#sync-with-beanie-202402","title":"Sync With Beanie | 2024.02","text":"<ul> <li>Author - Roman Right</li> <li>PR https://github.com/roman-right/bunnet/pull/20</li> </ul>"},{"location":"changelog/#120-2023-10-14","title":"1.2.0 - 2023-10-14","text":""},{"location":"changelog/#sync-with-beanie-202310","title":"Sync With Beanie | 2023.10","text":"<ul> <li>Author - Roman Right</li> <li>PR https://github.com/roman-right/bunnet/pull/16</li> </ul>"},{"location":"changelog/#110-2023-01-19","title":"1.1.0 - 2023-01-19","text":""},{"location":"changelog/#sync","title":"Sync","text":"<ul> <li>Beanie version: 1.16.8</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Previous saved state</li> <li>Remove yarl dependency</li> <li>Support for fetching deep-nested Links</li> <li>Lazy parsing for find many</li> </ul>"},{"location":"changelog/#implementation","title":"Implementation","text":"<ul> <li>ISSUE https://github.com/roman-right/beanie/issues/422</li> </ul>"},{"location":"changelog/#101-2022-11-18","title":"1.0.1 - 2022-11-18","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>Wrong inheritance behavior with non-rooted documents</li> </ul>"},{"location":"changelog/#implementation_1","title":"Implementation","text":"<ul> <li>ISSUE https://github.com/roman-right/beanie/issues/422</li> </ul>"},{"location":"changelog/#100-2022-11-14","title":"1.0.0 - 2022-11-14","text":""},{"location":"changelog/#feature","title":"Feature","text":"<ul> <li>Add migrations</li> <li>Bunnet has nearly all the features that Beanie has</li> </ul>"},{"location":"changelog/#implementation_2","title":"Implementation","text":"<ul> <li>PR https://github.com/roman-right/bunnet/pull/4</li> </ul>"},{"location":"changelog/#011-2022-11-07","title":"0.1.1 - 2022-11-07","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>Pass pymongo kwargs to the bulk writer</li> </ul>"},{"location":"changelog/#implementation_3","title":"Implementation","text":"<ul> <li>PR https://github.com/roman-right/bunnet/pull/3</li> </ul>"},{"location":"changelog/#010-2022-11-05","title":"0.1.0 - 2022-11-05","text":""},{"location":"changelog/#feature_1","title":"Feature","text":"<ul> <li>Multi-model behavior for inherited documents</li> </ul>"},{"location":"changelog/#implementation_4","title":"Implementation","text":"<ul> <li>PR https://github.com/roman-right/bunnet/pull/2</li> </ul>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code-of-conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at roman-right@protonmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code-of-conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code-of-conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code-of-conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code-of-conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code-of-conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"development/","title":"Development","text":"<p>Hopefully, you have landed here because you would like to help out with the development of Bunnet. Whether through adding new features, fixing bugs, or extending documentation, your help is really appreciated! Please read this page carefully. If you have any questions, drop by on the discord.</p> <p>Also, please read the Code of Conduct.</p>"},{"location":"development/#setting-up-the-development-environment","title":"Setting up the development environment","text":"<p>We assume you are familiar with the general forking and pull request workflow for submitting to open-source projects. If not, don't worry, there are plenty of good guides available. Maybe check out this one.</p> <p>All the dependencies and build configs are set in the <code>pyproject.toml</code> file. There are three main dependency sections there:</p> <ul> <li>dependencies: for the dependencies required to run Bunnet</li> <li>test: for the dependencies required to run tests</li> <li>doc: for the dependencies required to build the documentation</li> </ul> <p>To install all required dependencies, including test dependencies, in a virtual environment, run the following command in the root directory of the Bunnet project:</p> <pre><code>pip install -e .[test]\n</code></pre> <p>To install dependencies required for building the documentation, run:</p> <pre><code>pip install -e .[doc]\n</code></pre>"},{"location":"development/#database-connection","title":"Database connection","text":"<p>To run tests and use Bunnet in general, you will need an accessible MongoDB database. To use migrations, you will need a connection to a Replica Set or Mongos instance. All tests assume that the database is hosted locally on port <code>27017</code> and do not require authentication.</p>"},{"location":"development/#testing","title":"Testing","text":"<p>Bunnet uses pytest for unit testing. To ensure the stability of Bunnet, each added feature must be tested in a separate unit test, even if it looks like other tests are covering it now. This strategy guarantees that:</p> <ul> <li>All the features will be covered and stay covered.</li> <li>There is independence from other features and test cases.</li> </ul> <p>To run the test suite, make sure that you have MongoDB running and run <code>pytest</code>.</p>"},{"location":"development/#submitting-new-code","title":"Submitting new code","text":"<p>You can submit your changes through a pull request on GitHub. Please take into account the following sections.</p>"},{"location":"development/#use-pre-commit","title":"Use pre-commit","text":"<p>To ensure code consistency, Bunnet uses Black and Ruff through pre-commit. To set it up, run:</p> <pre><code>pre-commit install\n</code></pre> <p>This will add the pre-commit command to your git's pre-commit hooks and make sure you never forget to run these.</p>"},{"location":"development/#single-commit","title":"Single commit","text":"<p>To make the pull request reviewing easier and keep the version tree clean, your pull request should consist of a single commit. It is natural that your branch might contain multiple commits, so you will need to squash these into a single commit. Instructions can be found here or here.</p>"},{"location":"development/#add-documentation","title":"Add documentation","text":"<p>Please write clear documentation for any new functionality you add. Docstrings will be converted to the API documentation, but more human-friendly documentation might also be needed! See the section below.</p>"},{"location":"development/#working-on-the-documentation","title":"Working on the documentation","text":"<p>The documentation is generated using <code>pydoc-markdown</code>. To see a preview of any edits you make, you can run:</p> <pre><code>pydoc-markdown --server\n</code></pre> <p>and visit the printed address (usually <code>localhost:8000</code>) in your browser. Beware, the auto-recompiling might not work for everyone. This will automatically generate the API documentation from the source. All other documentation should be written by hand. The documentation is compiled using <code>mkdocs</code> behind the scenes. To change the table of contents or other options, check out <code>pydoc-markdown.yml</code>.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installing-bunnet","title":"Installing bunnet","text":"<p>You can simply install Bunnet from the PyPI:</p>"},{"location":"getting-started/#pip","title":"PIP","text":"<pre><code>pip install bunnet\n</code></pre>"},{"location":"getting-started/#poetry","title":"Poetry","text":"<pre><code>poetry add bunnet\n</code></pre>"},{"location":"getting-started/#initialization","title":"Initialization","text":"<p>Getting Bunnet setup in your code is really easy:</p> <ol> <li>Write your database model as a Pydantic class but use <code>bunnet.Document</code> instead of <code>pydantic.BaseModel</code>.</li> <li>Initialize MongoClient, as Bunnet uses this as an database engine under the hood.</li> <li>Call <code>bunnet.init_bunnet</code> with the PyMongo client and list of Bunnet models</li> </ol> <p>The code below should get you started and shows some of the field types that you can use with bunnet.</p> <pre><code>from typing import Optional\n\nfrom pymongo import MongoClient\nfrom pydantic import BaseModel\n\nfrom bunnet import Document, Indexed, init_bunnet\n\n\nclass Category(BaseModel):\n    name: str\n    description: str\n\n\n# This is the model that will be saved to the database\nclass Product(Document):\n    name: str                          # You can use normal types just like in pydantic\n    description: Optional[str] = None\n    price: Indexed(float)              # You can also specify that a field should correspond to an index\n    category: Category                 # You can include pydantic models as well\n\n# Call this to get bunnet setup.\ndef init():\n    # Create PyMongo client\n    client = MongoClient(\n        \"mongodb://user:pass@host:27017\"\n    )\n\n    # Initialize bunnet with the Product document class and a database\n    init_bunnet(database=client.db_name, document_models=[Product])\n</code></pre>"},{"location":"api-documentation/document/","title":"Document","text":""},{"location":"api-documentation/document/#bunnetodmdocuments","title":"bunnet.odm.documents","text":""},{"location":"api-documentation/document/#document","title":"Document","text":"<pre><code>class Document(LazyModel, SettersInterface, InheritanceInterface,\n               FindInterface, AggregateInterface, OtherGettersInterface)\n</code></pre> <p>Document Mapping class.</p> <p>Fields:</p> <ul> <li><code>id</code> - MongoDB document ObjectID \"_id\" field. Mapped to the PydanticObjectId class</li> </ul> <p></p>"},{"location":"api-documentation/document/#documentget","title":"Document.get","text":"<pre><code>@classmethod\ndef get(cls: Type[\"DocType\"],\n        document_id: Any,\n        session: Optional[ClientSession] = None,\n        ignore_cache: bool = False,\n        fetch_links: bool = False,\n        with_children: bool = False,\n        nesting_depth: Optional[int] = None,\n        nesting_depths_per_field: Optional[Dict[str, int]] = None,\n        **pymongo_kwargs) -&gt; Optional[\"DocType\"]\n</code></pre> <p>Get document by id, returns None if document does not exist</p> <p>Arguments:</p> <ul> <li><code>document_id</code>: PydanticObjectId - document id</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>ignore_cache</code>: bool - ignore cache (if it is turned on)</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation</li> </ul> <p>Returns:</p> <p>Union[\"Document\", None]</p> <p></p>"},{"location":"api-documentation/document/#documentsync","title":"Document.sync","text":"<pre><code>def sync(merge_strategy: MergeStrategy = MergeStrategy.remote)\n</code></pre> <p>Sync the document with the database</p> <p>Arguments:</p> <ul> <li><code>merge_strategy</code>: MergeStrategy - how to merge the document</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"api-documentation/document/#documentinsert","title":"Document.insert","text":"<pre><code>@wrap_with_actions(EventTypes.INSERT)\n@save_state_after\n@validate_self_before\ndef insert(\n    *,\n    link_rule: WriteRules = WriteRules.DO_NOTHING,\n    session: Optional[ClientSession] = None,\n    skip_actions: Optional[List[Union[ActionDirections,\n                                      str]]] = None) -&gt; DocType\n</code></pre> <p>Insert the document (self) to the collection</p> <p>Returns:</p> <p>Document</p> <p></p>"},{"location":"api-documentation/document/#documentcreate","title":"Document.create","text":"<pre><code>def create(session: Optional[ClientSession] = None) -&gt; DocType\n</code></pre> <p>The same as self.insert()</p> <p>Returns:</p> <p>Document</p> <p></p>"},{"location":"api-documentation/document/#documentinsert_one","title":"Document.insert_one","text":"<pre><code>@classmethod\ndef insert_one(\n        cls: Type[DocType],\n        document: DocType,\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[\"BulkWriter\"] = None,\n        link_rule: WriteRules = WriteRules.DO_NOTHING) -&gt; Optional[DocType]\n</code></pre> <p>Insert one document to the collection</p> <p>Arguments:</p> <ul> <li><code>document</code>: Document - document to insert</li> <li><code>session</code>: ClientSession - pymongo session</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>link_rule</code>: InsertRules - hot to manage link fields</li> </ul> <p>Returns:</p> <p>DocType</p> <p></p>"},{"location":"api-documentation/document/#documentinsert_many","title":"Document.insert_many","text":"<pre><code>@classmethod\ndef insert_many(cls: Type[DocType],\n                documents: Iterable[DocType],\n                session: Optional[ClientSession] = None,\n                link_rule: WriteRules = WriteRules.DO_NOTHING,\n                **pymongo_kwargs) -&gt; InsertManyResult\n</code></pre> <p>Insert many documents to the collection</p> <p>Arguments:</p> <ul> <li><code>documents</code>: List[\"Document\"] - documents to insert</li> <li><code>session</code>: ClientSession - pymongo session</li> <li><code>link_rule</code>: InsertRules - how to manage link fields</li> </ul> <p>Returns:</p> <p>InsertManyResult</p> <p></p>"},{"location":"api-documentation/document/#documentreplace","title":"Document.replace","text":"<pre><code>@wrap_with_actions(EventTypes.REPLACE)\n@save_state_after\n@validate_self_before\ndef replace(\n    ignore_revision: bool = False,\n    session: Optional[ClientSession] = None,\n    bulk_writer: Optional[BulkWriter] = None,\n    link_rule: WriteRules = WriteRules.DO_NOTHING,\n    skip_actions: Optional[List[Union[ActionDirections,\n                                      str]]] = None) -&gt; DocType\n</code></pre> <p>Fully update the document in the database</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession] - pymongo session.</li> <li><code>ignore_revision</code>: bool - do force replace. Used when revision based protection is turned on.</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/document/#documentsave","title":"Document.save","text":"<pre><code>@wrap_with_actions(EventTypes.SAVE)\n@save_state_after\n@validate_self_before\ndef save(session: Optional[ClientSession] = None,\n         link_rule: WriteRules = WriteRules.DO_NOTHING,\n         ignore_revision: bool = False,\n         **kwargs) -&gt; None\n</code></pre> <p>Update an existing model in the database or</p> <p>insert it if it does not yet exist.</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession] - pymongo session.</li> <li><code>link_rule</code>: WriteRules - rules how to deal with links on writing</li> <li><code>ignore_revision</code>: bool - do force save.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"api-documentation/document/#documentsave_changes","title":"Document.save_changes","text":"<pre><code>@saved_state_needed\n@wrap_with_actions(EventTypes.SAVE_CHANGES)\n@validate_self_before\ndef save_changes(\n        ignore_revision: bool = False,\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[BulkWriter] = None,\n        skip_actions: Optional[List[Union[ActionDirections,\n                                          str]]] = None) -&gt; None\n</code></pre> <p>Save changes.</p> <p>State management usage must be turned on</p> <p>Arguments:</p> <ul> <li><code>ignore_revision</code>: bool - ignore revision id, if revision is turned on</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"api-documentation/document/#documentreplace_many","title":"Document.replace_many","text":"<pre><code>@classmethod\ndef replace_many(cls: Type[DocType],\n                 documents: List[DocType],\n                 session: Optional[ClientSession] = None) -&gt; None\n</code></pre> <p>Replace list of documents</p> <p>Arguments:</p> <ul> <li><code>documents</code>: List[\"Document\"]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"api-documentation/document/#documentupdate","title":"Document.update","text":"<pre><code>@wrap_with_actions(EventTypes.UPDATE)\n@save_state_after\ndef update(*args,\n           ignore_revision: bool = False,\n           session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           skip_actions: Optional[List[Union[ActionDirections, str]]] = None,\n           skip_sync: Optional[bool] = None,\n           **pymongo_kwargs) -&gt; DocType\n</code></pre> <p>Partially update the document in the database</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>session</code>: ClientSession - pymongo session.</li> <li><code>ignore_revision</code>: bool - force update. Will update even if revision id is not the same, as stored</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"api-documentation/document/#documentupdate_all","title":"Document.update_all","text":"<pre><code>@classmethod\ndef update_all(cls,\n               *args: Union[dict, Mapping],\n               session: Optional[ClientSession] = None,\n               bulk_writer: Optional[BulkWriter] = None,\n               **pymongo_kwargs) -&gt; UpdateMany\n</code></pre> <p>Partially update all the documents</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>session</code>: ClientSession - pymongo session.</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/document/#documentset","title":"Document.set","text":"<pre><code>def set(expression: Dict[Union[ExpressionField, str], Any],\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[BulkWriter] = None,\n        skip_sync: Optional[bool] = None,\n        **kwargs)\n</code></pre> <p>Set values</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nDocument.find(Sample.one == 1).set({Sample.one: 100})\n</code></pre> <p>Uses Set operator</p> <p>Arguments:</p> <ul> <li><code>expression</code>: Dict[Union[ExpressionField, str], Any] - keys and values to set</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bulk writer</li> <li><code>skip_sync</code>: bool - skip doc syncing. Available for the direct instances only</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/document/#documentcurrent_date","title":"Document.current_date","text":"<pre><code>def current_date(expression: Dict[Union[ExpressionField, str], Any],\n                 session: Optional[ClientSession] = None,\n                 bulk_writer: Optional[BulkWriter] = None,\n                 skip_sync: Optional[bool] = None,\n                 **kwargs)\n</code></pre> <p>Set current date</p> <p>Uses CurrentDate operator</p> <p>Arguments:</p> <ul> <li><code>expression</code>: Dict[Union[ExpressionField, str], Any]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bulk writer</li> <li><code>skip_sync</code>: bool - skip doc syncing. Available for the direct instances only</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/document/#documentinc","title":"Document.inc","text":"<pre><code>def inc(expression: Dict[Union[ExpressionField, str], Any],\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[BulkWriter] = None,\n        skip_sync: Optional[bool] = None,\n        **kwargs)\n</code></pre> <p>Increment</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nDocument.find(Sample.one == 1).inc({Sample.one: 100})\n</code></pre> <p>Uses Inc operator</p> <p>Arguments:</p> <ul> <li><code>expression</code>: Dict[Union[ExpressionField, str], Any]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bulk writer</li> <li><code>skip_sync</code>: bool - skip doc syncing. Available for the direct instances only</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/document/#documentdelete","title":"Document.delete","text":"<pre><code>@wrap_with_actions(EventTypes.DELETE)\ndef delete(session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           link_rule: DeleteRules = DeleteRules.DO_NOTHING,\n           skip_actions: Optional[List[Union[ActionDirections, str]]] = None,\n           **pymongo_kwargs) -&gt; Optional[DeleteResult]\n</code></pre> <p>Delete the document</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession] - pymongo session.</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>link_rule</code>: DeleteRules - rules for link fields</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for delete operation</li> </ul> <p>Returns:</p> <p>Optional[DeleteResult] - pymongo DeleteResult instance.</p> <p></p>"},{"location":"api-documentation/document/#documentdelete_all","title":"Document.delete_all","text":"<pre><code>@classmethod\ndef delete_all(cls,\n               session: Optional[ClientSession] = None,\n               bulk_writer: Optional[BulkWriter] = None,\n               **pymongo_kwargs) -&gt; Optional[DeleteResult]\n</code></pre> <p>Delete all the documents</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession] - pymongo session.</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for delete operation</li> </ul> <p>Returns:</p> <p>Optional[DeleteResult] - pymongo DeleteResult instance.</p> <p></p>"},{"location":"api-documentation/document/#documentuse_state_management","title":"Document.use_state_management","text":"<pre><code>@classmethod\ndef use_state_management(cls) -&gt; bool\n</code></pre> <p>Is state management turned on</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"api-documentation/document/#documentstate_management_save_previous","title":"Document.state_management_save_previous","text":"<pre><code>@classmethod\ndef state_management_save_previous(cls) -&gt; bool\n</code></pre> <p>Should we save the previous state after a commit to database</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"api-documentation/document/#documentstate_management_replace_objects","title":"Document.state_management_replace_objects","text":"<pre><code>@classmethod\ndef state_management_replace_objects(cls) -&gt; bool\n</code></pre> <p>Should objects be replaced when using state management</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"api-documentation/document/#documentget_saved_state","title":"Document.get_saved_state","text":"<pre><code>def get_saved_state() -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Saved state getter. It is protected property.</p> <p>Returns:</p> <p>Optional[Dict[str, Any]] - saved state</p> <p></p>"},{"location":"api-documentation/document/#documentget_previous_saved_state","title":"Document.get_previous_saved_state","text":"<pre><code>def get_previous_saved_state() -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Previous state getter. It is a protected property.</p> <p>Returns:</p> <p>Optional[Dict[str, Any]] - previous state</p> <p></p>"},{"location":"api-documentation/document/#documentget_settings","title":"Document.get_settings","text":"<pre><code>@classmethod\ndef get_settings(cls) -&gt; DocumentSettings\n</code></pre> <p>Get document settings, which was created on</p> <p>the initialization step</p> <p>Returns:</p> <p>DocumentSettings class</p> <p></p>"},{"location":"api-documentation/document/#documentinspect_collection","title":"Document.inspect_collection","text":"<pre><code>@classmethod\ndef inspect_collection(cls,\n                       session: Optional[ClientSession] = None\n                       ) -&gt; InspectionResult\n</code></pre> <p>Check, if documents, stored in the MongoDB collection</p> <p>are compatible with the Document schema</p> <p>Returns:</p> <p>InspectionResult</p>"},{"location":"api-documentation/fields/","title":"Fields","text":""},{"location":"api-documentation/fields/#bunnetodmfields","title":"bunnet.odm.fields","text":""},{"location":"api-documentation/fields/#indexed","title":"Indexed","text":"<pre><code>def Indexed(typ=None, index_type=ASCENDING, **kwargs)\n</code></pre> <p>If <code>typ</code> is defined, returns a subclass of <code>typ</code> with an extra attribute <code>_indexed</code> as a tuple: - Index 0: <code>index_type</code> such as <code>pymongo.ASCENDING</code> - Index 1: <code>kwargs</code> passed to <code>IndexModel</code> When instantiated the type of the result will actually be <code>typ</code>.</p> <p>When <code>typ</code> is not defined, returns an <code>IndexedAnnotation</code> instance, to be used as metadata in <code>Annotated</code> fields.</p> <p>Example:</p> <pre><code># Both fields would have the same behavior\nclass MyModel(BaseModel):\n    field1: Indexed(str, unique=True)\n    field2: Annotated[str, Indexed(unique=True)]\n</code></pre> <p></p>"},{"location":"api-documentation/fields/#pydanticobjectid","title":"PydanticObjectId","text":"<pre><code>class PydanticObjectId(ObjectId)\n</code></pre> <p>Object Id field. Compatible with Pydantic.</p> <p></p>"},{"location":"api-documentation/fields/#expressionfield","title":"ExpressionField","text":"<pre><code>class ExpressionField(str)\n</code></pre>"},{"location":"api-documentation/fields/#expressionfield__getitem__","title":"ExpressionField.__getitem__","text":"<pre><code>def __getitem__(item)\n</code></pre> <p>Get sub field</p> <p>Arguments:</p> <ul> <li><code>item</code>: name of the subfield</li> </ul> <p>Returns:</p> <p>ExpressionField</p> <p></p>"},{"location":"api-documentation/fields/#expressionfield__getattr__","title":"ExpressionField.__getattr__","text":"<pre><code>def __getattr__(item)\n</code></pre> <p>Get sub field</p> <p>Arguments:</p> <ul> <li><code>item</code>: name of the subfield</li> </ul> <p>Returns:</p> <p>ExpressionField</p> <p></p>"},{"location":"api-documentation/fields/#linkinfo","title":"LinkInfo","text":"<pre><code>class LinkInfo(BaseModel)\n</code></pre>"},{"location":"api-documentation/fields/#linkinfodocument_class","title":"LinkInfo.document_class","text":"<p>Document class</p> <p></p>"},{"location":"api-documentation/fields/#link","title":"Link","text":"<pre><code>class Link(Generic[T])\n</code></pre>"},{"location":"api-documentation/fields/#linkfetch_list","title":"Link.fetch_list","text":"<pre><code>@classmethod\ndef fetch_list(cls,\n               links: List[Union[\"Link\", \"DocType\"]],\n               fetch_links: bool = False)\n</code></pre> <p>Fetch list that contains links and documents</p> <p>Arguments:</p> <ul> <li><code>links</code>: </li> <li><code>fetch_links</code>: </li> </ul> <p></p>"},{"location":"api-documentation/fields/#backlink","title":"BackLink","text":"<pre><code>class BackLink(Generic[T])\n</code></pre> <p>Back reference to a document</p>"},{"location":"api-documentation/interfaces/","title":"Interfaces","text":""},{"location":"api-documentation/interfaces/#bunnetodminterfacesgetters","title":"bunnet.odm.interfaces.getters","text":""},{"location":"api-documentation/interfaces/#bunnetodminterfacesdetector","title":"bunnet.odm.interfaces.detector","text":""},{"location":"api-documentation/interfaces/#bunnetodminterfacesupdate","title":"bunnet.odm.interfaces.update","text":""},{"location":"api-documentation/interfaces/#updatemethods","title":"UpdateMethods","text":"<pre><code>class UpdateMethods()\n</code></pre> <p>Update methods</p> <p></p>"},{"location":"api-documentation/interfaces/#updatemethodsset","title":"UpdateMethods.set","text":"<pre><code>def set(expression: Dict[Union[ExpressionField, str], Any],\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[BulkWriter] = None,\n        **kwargs)\n</code></pre> <p>Set values</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nDocument.find(Sample.one == 1).set({Sample.one: 100})\n</code></pre> <p>Uses Set operator</p> <p>Arguments:</p> <ul> <li><code>expression</code>: Dict[Union[ExpressionField, str], Any] - keys and values to set</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bulk writer</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/interfaces/#updatemethodscurrent_date","title":"UpdateMethods.current_date","text":"<pre><code>def current_date(expression: Dict[Union[ExpressionField, str], Any],\n                 session: Optional[ClientSession] = None,\n                 bulk_writer: Optional[BulkWriter] = None,\n                 **kwargs)\n</code></pre> <p>Set current date</p> <p>Uses CurrentDate operator</p> <p>Arguments:</p> <ul> <li><code>expression</code>: Dict[Union[ExpressionField, str], Any]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bulk writer</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/interfaces/#updatemethodsinc","title":"UpdateMethods.inc","text":"<pre><code>def inc(expression: Dict[Union[ExpressionField, str], Any],\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[BulkWriter] = None,\n        **kwargs)\n</code></pre> <p>Increment</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nDocument.find(Sample.one == 1).inc({Sample.one: 100})\n</code></pre> <p>Uses Inc operator</p> <p>Arguments:</p> <ul> <li><code>expression</code>: Dict[Union[ExpressionField, str], Any]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bulk writer</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/interfaces/#bunnetodminterfacesfind","title":"bunnet.odm.interfaces.find","text":""},{"location":"api-documentation/interfaces/#findinterface","title":"FindInterface","text":"<pre><code>class FindInterface()\n</code></pre>"},{"location":"api-documentation/interfaces/#findinterfacefind_one","title":"FindInterface.find_one","text":"<pre><code>@classmethod\ndef find_one(\n    cls: Type[FindType],\n    *args: Union[Mapping[str, Any], bool],\n    projection_model: Optional[Type[\"DocumentProjectionType\"]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    fetch_links: bool = False,\n    with_children: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[FindOne[FindType], FindOne[\"DocumentProjectionType\"]]\n</code></pre> <p>Find one document by criteria.</p> <p>Returns FindOne query object. When awaited this will either return a document or None if no document exists for the search criteria.</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str, Any] - search criteria</li> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> <li><code>session</code>: Optional[ClientSession] - pymongo session instance</li> <li><code>ignore_cache</code>: bool</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)</li> </ul> <p>Returns:</p> <p>FindOne - find query instance</p> <p></p>"},{"location":"api-documentation/interfaces/#findinterfacefind_many","title":"FindInterface.find_many","text":"<pre><code>@classmethod\ndef find_many(\n    cls: Type[FindType],\n    *args: Union[Mapping[str, Any], bool],\n    projection_model: Optional[Type[\"DocumentProjectionType\"]] = None,\n    skip: Optional[int] = None,\n    limit: Optional[int] = None,\n    sort: Union[None, str, List[Tuple[str, SortDirection]]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    fetch_links: bool = False,\n    with_children: bool = False,\n    lazy_parse: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[FindMany[FindType], FindMany[\"DocumentProjectionType\"]]\n</code></pre> <p>Find many documents by criteria.</p> <p>Returns FindMany query object</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str, Any] - search criteria</li> <li><code>skip</code>: Optional[int] - The number of documents to omit.</li> <li><code>limit</code>: Optional[int] - The maximum number of results to return.</li> <li><code>sort</code>: Union[None, str, List[Tuple[str, SortDirection]]] - A key or a list of (key, direction) pairs specifying the sort order for this query.</li> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>ignore_cache</code>: bool</li> <li><code>lazy_parse</code>: bool</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)</li> </ul> <p>Returns:</p> <p>FindMany - query instance</p> <p></p>"},{"location":"api-documentation/interfaces/#findinterfacefind","title":"FindInterface.find","text":"<pre><code>@classmethod\ndef find(\n    cls: Type[FindType],\n    *args: Union[Mapping[str, Any], bool],\n    projection_model: Optional[Type[\"DocumentProjectionType\"]] = None,\n    skip: Optional[int] = None,\n    limit: Optional[int] = None,\n    sort: Union[None, str, List[Tuple[str, SortDirection]]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    fetch_links: bool = False,\n    with_children: bool = False,\n    lazy_parse: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[FindMany[FindType], FindMany[\"DocumentProjectionType\"]]\n</code></pre> <p>The same as find_many</p> <p></p>"},{"location":"api-documentation/interfaces/#findinterfacefind_all","title":"FindInterface.find_all","text":"<pre><code>@classmethod\ndef find_all(\n    cls: Type[FindType],\n    skip: Optional[int] = None,\n    limit: Optional[int] = None,\n    sort: Union[None, str, List[Tuple[str, SortDirection]]] = None,\n    projection_model: Optional[Type[\"DocumentProjectionType\"]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    with_children: bool = False,\n    lazy_parse: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[FindMany[FindType], FindMany[\"DocumentProjectionType\"]]\n</code></pre> <p>Get all the documents</p> <p>Arguments:</p> <ul> <li><code>skip</code>: Optional[int] - The number of documents to omit.</li> <li><code>limit</code>: Optional[int] - The maximum number of results to return.</li> <li><code>sort</code>: Union[None, str, List[Tuple[str, SortDirection]]] - A key or a list of (key, direction) pairs specifying the sort order for this query.</li> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)</li> </ul> <p>Returns:</p> <p>FindMany - query instance</p> <p></p>"},{"location":"api-documentation/interfaces/#findinterfaceall","title":"FindInterface.all","text":"<pre><code>@classmethod\ndef all(\n    cls: Type[FindType],\n    projection_model: Optional[Type[\"DocumentProjectionType\"]] = None,\n    skip: Optional[int] = None,\n    limit: Optional[int] = None,\n    sort: Union[None, str, List[Tuple[str, SortDirection]]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    with_children: bool = False,\n    lazy_parse: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[FindMany[FindType], FindMany[\"DocumentProjectionType\"]]\n</code></pre> <p>the same as find_all</p> <p></p>"},{"location":"api-documentation/interfaces/#findinterfacecount","title":"FindInterface.count","text":"<pre><code>@classmethod\ndef count(cls) -&gt; int\n</code></pre> <p>Number of documents in the collections</p> <p>The same as find_all().count()</p> <p>Returns:</p> <p>int</p> <p></p>"},{"location":"api-documentation/interfaces/#bunnetodminterfacessetters","title":"bunnet.odm.interfaces.setters","text":""},{"location":"api-documentation/interfaces/#settersinterface","title":"SettersInterface","text":"<pre><code>class SettersInterface()\n</code></pre>"},{"location":"api-documentation/interfaces/#settersinterfaceset_collection","title":"SettersInterface.set_collection","text":"<pre><code>@classmethod\ndef set_collection(cls, collection)\n</code></pre> <p>Collection setter</p> <p></p>"},{"location":"api-documentation/interfaces/#settersinterfaceset_database","title":"SettersInterface.set_database","text":"<pre><code>@classmethod\ndef set_database(cls, database)\n</code></pre> <p>Database setter</p> <p></p>"},{"location":"api-documentation/interfaces/#settersinterfaceset_collection_name","title":"SettersInterface.set_collection_name","text":"<pre><code>@classmethod\ndef set_collection_name(cls, name: str)\n</code></pre> <p>Collection name setter</p> <p></p>"},{"location":"api-documentation/interfaces/#bunnetodminterfacesrun","title":"bunnet.odm.interfaces.run","text":""},{"location":"api-documentation/interfaces/#bunnetodminterfacessession","title":"bunnet.odm.interfaces.session","text":""},{"location":"api-documentation/interfaces/#sessionmethods","title":"SessionMethods","text":"<pre><code>class SessionMethods()\n</code></pre> <p>Session methods</p> <p></p>"},{"location":"api-documentation/interfaces/#sessionmethodsset_session","title":"SessionMethods.set_session","text":"<pre><code>def set_session(session: Optional[ClientSession] = None)\n</code></pre> <p>Set pymongo session</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> </ul> <p></p>"},{"location":"api-documentation/interfaces/#bunnetodminterfacesaggregate","title":"bunnet.odm.interfaces.aggregate","text":""},{"location":"api-documentation/interfaces/#aggregateinterface","title":"AggregateInterface","text":"<pre><code>class AggregateInterface()\n</code></pre>"},{"location":"api-documentation/interfaces/#aggregateinterfaceaggregate","title":"AggregateInterface.aggregate","text":"<pre><code>@classmethod\ndef aggregate(\n    cls: Type[DocType],\n    aggregation_pipeline: list,\n    projection_model: Optional[Type[DocumentProjectionType]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    **pymongo_kwargs\n) -&gt; Union[\n        AggregationQuery[Dict[str, Any]],\n        AggregationQuery[DocumentProjectionType],\n]\n</code></pre> <p>Aggregate over collection.</p> <p>Returns AggregationQuery query object</p> <p>Arguments:</p> <ul> <li><code>aggregation_pipeline</code>: list - aggregation pipeline</li> <li><code>projection_model</code>: Type[BaseModel]</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>ignore_cache</code>: bool</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for aggregate operation</li> </ul> <p>Returns:</p> <p>AggregationQuery</p> <p></p>"},{"location":"api-documentation/interfaces/#bunnetodminterfacesinheritance","title":"bunnet.odm.interfaces.inheritance","text":""},{"location":"api-documentation/interfaces/#bunnetodminterfacesaggregation_methods","title":"bunnet.odm.interfaces.aggregation_methods","text":""},{"location":"api-documentation/interfaces/#aggregatemethods","title":"AggregateMethods","text":"<pre><code>class AggregateMethods()\n</code></pre> <p>Aggregate methods</p> <p></p>"},{"location":"api-documentation/interfaces/#aggregatemethodssum","title":"AggregateMethods.sum","text":"<pre><code>def sum(field: Union[str, ExpressionField],\n        session: Optional[ClientSession] = None,\n        ignore_cache: bool = False) -&gt; Optional[float]\n</code></pre> <p>Sum of values of the given field</p> <p>Example:</p> <pre><code>class Sample(Document):\n    price: int\n    count: int\n\nsum_count = Document.find(Sample.price &lt;= 100).sum(Sample.count)\n</code></pre> <p>Arguments:</p> <ul> <li><code>field</code>: Union[str, ExpressionField]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>ignore_cache</code>: bool</li> </ul> <p>Returns:</p> <p>float - sum. None if there are no items.</p> <p></p>"},{"location":"api-documentation/interfaces/#aggregatemethodsavg","title":"AggregateMethods.avg","text":"<pre><code>def avg(field,\n        session: Optional[ClientSession] = None,\n        ignore_cache: bool = False) -&gt; Optional[float]\n</code></pre> <p>Average of values of the given field</p> <p>Example:</p> <pre><code>class Sample(Document):\n    price: int\n    count: int\n\navg_count = Document.find(Sample.price &lt;= 100).avg(Sample.count)\n</code></pre> <p>Arguments:</p> <ul> <li><code>field</code>: Union[str, ExpressionField]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>ignore_cache</code>: bool</li> </ul> <p>Returns:</p> <p>Optional[float] - avg. None if there are no items.</p> <p></p>"},{"location":"api-documentation/interfaces/#aggregatemethodsmax","title":"AggregateMethods.max","text":"<pre><code>def max(field: Union[str, ExpressionField],\n        session: Optional[ClientSession] = None,\n        ignore_cache: bool = False) -&gt; Optional[float]\n</code></pre> <p>Max of the values of the given field</p> <p>Example:</p> <pre><code>class Sample(Document):\n    price: int\n    count: int\n\nmax_count = Document.find(Sample.price &lt;= 100).max(Sample.count)\n</code></pre> <p>Arguments:</p> <ul> <li><code>field</code>: Union[str, ExpressionField]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> </ul> <p>Returns:</p> <p>float - max. None if there are no items.</p> <p></p>"},{"location":"api-documentation/interfaces/#aggregatemethodsmin","title":"AggregateMethods.min","text":"<pre><code>def min(field: Union[str, ExpressionField],\n        session: Optional[ClientSession] = None,\n        ignore_cache: bool = False) -&gt; Optional[float]\n</code></pre> <p>Min of the values of the given field</p> <p>Example:</p> <pre><code>class Sample(Document):\n    price: int\n    count: int\n\nmin_count = Document.find(Sample.price &lt;= 100).min(Sample.count)\n</code></pre> <p>Arguments:</p> <ul> <li><code>field</code>: Union[str, ExpressionField]</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> </ul> <p>Returns:</p> <p>float - min. None if there are no items.</p> <p></p>"},{"location":"api-documentation/interfaces/#bunnetodminterfacesclone","title":"bunnet.odm.interfaces.clone","text":""},{"location":"api-documentation/query/","title":"Query","text":""},{"location":"api-documentation/query/#bunnetodmqueriesupdate","title":"bunnet.odm.queries.update","text":""},{"location":"api-documentation/query/#updateresponse","title":"UpdateResponse","text":"<pre><code>class UpdateResponse(str, Enum)\n</code></pre>"},{"location":"api-documentation/query/#updateresponseupdate_result","title":"UpdateResponse.UPDATE_RESULT","text":"<p>PyMongo update result</p> <p></p>"},{"location":"api-documentation/query/#updateresponseold_document","title":"UpdateResponse.OLD_DOCUMENT","text":"<p>Original document</p> <p></p>"},{"location":"api-documentation/query/#updateresponsenew_document","title":"UpdateResponse.NEW_DOCUMENT","text":"<p>Updated document</p> <p></p>"},{"location":"api-documentation/query/#updatequery","title":"UpdateQuery","text":"<pre><code>class UpdateQuery(UpdateMethods, SessionMethods, RunInterface, CloneInterface)\n</code></pre> <p>Update Query base class</p> <p></p>"},{"location":"api-documentation/query/#updatemany","title":"UpdateMany","text":"<pre><code>class UpdateMany(UpdateQuery)\n</code></pre> <p>Update Many query class</p> <p></p>"},{"location":"api-documentation/query/#updatemanyupdate","title":"UpdateMany.update","text":"<pre><code>def update(*args: Mapping[str, Any],\n           session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           **pymongo_kwargs) -&gt; \"UpdateQuery\"\n</code></pre> <p>Provide modifications to the update query.</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>bulk_writer</code>: Optional[BulkWriter]</li> <li><code>pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#updatemanyupsert","title":"UpdateMany.upsert","text":"<pre><code>def upsert(*args: Mapping[str, Any],\n           on_insert: \"DocType\",\n           session: Optional[ClientSession] = None,\n           **pymongo_kwargs) -&gt; \"UpdateQuery\"\n</code></pre> <p>Provide modifications to the upsert query.</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>on_insert</code>: DocType - document to insert if there is no matched document in the collection</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#updatemanyupdate_many","title":"UpdateMany.update_many","text":"<pre><code>def update_many(*args: Mapping[str, Any],\n                session: Optional[ClientSession] = None,\n                bulk_writer: Optional[BulkWriter] = None,\n                **pymongo_kwargs)\n</code></pre> <p>Provide modifications to the update query</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#updatemanyrun","title":"UpdateMany.run","text":"<pre><code>def run()\n</code></pre> <p>Run the query </p> <p></p>"},{"location":"api-documentation/query/#updateone","title":"UpdateOne","text":"<pre><code>class UpdateOne(UpdateQuery)\n</code></pre> <p>Update One query class</p> <p></p>"},{"location":"api-documentation/query/#updateoneupdate","title":"UpdateOne.update","text":"<pre><code>def update(*args: Mapping[str, Any],\n           session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           response_type: Optional[UpdateResponse] = None,\n           **pymongo_kwargs) -&gt; \"UpdateQuery\"\n</code></pre> <p>Provide modifications to the update query.</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>bulk_writer</code>: Optional[BulkWriter]</li> <li><code>response_type</code>: UpdateResponse</li> <li><code>pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#updateoneupsert","title":"UpdateOne.upsert","text":"<pre><code>def upsert(*args: Mapping[str, Any],\n           on_insert: \"DocType\",\n           session: Optional[ClientSession] = None,\n           response_type: Optional[UpdateResponse] = None,\n           **pymongo_kwargs) -&gt; \"UpdateQuery\"\n</code></pre> <p>Provide modifications to the upsert query.</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>on_insert</code>: DocType - document to insert if there is no matched document in the collection</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>response_type</code>: Optional[UpdateResponse]</li> <li><code>pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#updateoneupdate_one","title":"UpdateOne.update_one","text":"<pre><code>def update_one(*args: Mapping[str, Any],\n               session: Optional[ClientSession] = None,\n               bulk_writer: Optional[BulkWriter] = None,\n               response_type: Optional[UpdateResponse] = None,\n               **pymongo_kwargs)\n</code></pre> <p>Provide modifications to the update query. The same as <code>update()</code></p> <p>Arguments:</p> <ul> <li><code>args</code>: *Union[dict, Mapping] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>bulk_writer</code>: \"BulkWriter\" - bunnet bulk writer</li> <li><code>response_type</code>: Optional[UpdateResponse]</li> <li><code>pymongo_kwargs</code>: pymongo native parameters for update operation</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#updateonerun","title":"UpdateOne.run","text":"<pre><code>def run() -&gt; Union[UpdateResult, InsertOneResult, Optional[\"DocType\"]]\n</code></pre> <p>Run the query </p> <p></p>"},{"location":"api-documentation/query/#bunnetodmqueriesaggregation","title":"bunnet.odm.queries.aggregation","text":""},{"location":"api-documentation/query/#aggregationquery","title":"AggregationQuery","text":"<pre><code>class AggregationQuery(Generic[AggregationProjectionType],\n                       BaseCursorQuery[AggregationProjectionType],\n                       SessionMethods, CloneInterface)\n</code></pre> <p>Aggregation Query</p> <p></p>"},{"location":"api-documentation/query/#bunnetodmqueriesfind","title":"bunnet.odm.queries.find","text":""},{"location":"api-documentation/query/#findquery","title":"FindQuery","text":"<pre><code>class FindQuery(Generic[FindQueryResultType], UpdateMethods, SessionMethods,\n                CloneInterface)\n</code></pre> <p>Find Query base class</p> <p></p>"},{"location":"api-documentation/query/#findqueryget_filter_query","title":"FindQuery.get_filter_query","text":"<pre><code>def get_filter_query() -&gt; Mapping[str, Any]\n</code></pre> <p>Returns: MongoDB filter query</p> <p></p>"},{"location":"api-documentation/query/#findquerydelete","title":"FindQuery.delete","text":"<pre><code>def delete(session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           **pymongo_kwargs) -&gt; Union[DeleteOne, DeleteMany]\n</code></pre> <p>Provide search criteria to the Delete query</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession]</li> </ul> <p>Returns:</p> <p>Union[DeleteOne, DeleteMany]</p> <p></p>"},{"location":"api-documentation/query/#findqueryproject","title":"FindQuery.project","text":"<pre><code>def project(projection_model)\n</code></pre> <p>Apply projection parameter</p> <p>Arguments:</p> <ul> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/query/#findquerycount","title":"FindQuery.count","text":"<pre><code>def count() -&gt; int\n</code></pre> <p>Number of found documents</p> <p>Returns:</p> <p>int</p> <p></p>"},{"location":"api-documentation/query/#findqueryexists","title":"FindQuery.exists","text":"<pre><code>def exists() -&gt; bool\n</code></pre> <p>If find query will return anything</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"api-documentation/query/#findmany","title":"FindMany","text":"<pre><code>class FindMany(FindQuery[FindQueryResultType],\n               BaseCursorQuery[FindQueryResultType], AggregateMethods)\n</code></pre> <p>Find Many query class</p> <p></p>"},{"location":"api-documentation/query/#findmanyfind_many","title":"FindMany.find_many","text":"<pre><code>def find_many(\n    *args: Union[Mapping[str, Any], bool],\n    projection_model: Optional[Type[FindQueryProjectionType]] = None,\n    skip: Optional[int] = None,\n    limit: Optional[int] = None,\n    sort: Union[None, str, List[Tuple[str, SortDirection]]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    fetch_links: bool = False,\n    lazy_parse: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[\"FindMany[FindQueryResultType]\",\n           \"FindMany[FindQueryProjectionType]\"]\n</code></pre> <p>Find many documents by criteria</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str, Any] - search criteria</li> <li><code>skip</code>: Optional[int] - The number of documents to omit.</li> <li><code>limit</code>: Optional[int] - The maximum number of results to return.</li> <li><code>sort</code>: Union[None, str, List[Tuple[str, SortDirection]]] - A key or a list of (key, direction) pairs specifying the sort order for this query.</li> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>ignore_cache</code>: bool</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)</li> </ul> <p>Returns:</p> <p>FindMany - query instance</p> <p></p>"},{"location":"api-documentation/query/#findmanyproject","title":"FindMany.project","text":"<pre><code>def project(\n    projection_model: Optional[Type[FindQueryProjectionType]]\n) -&gt; Union[\"FindMany[FindQueryResultType]\",\n           \"FindMany[FindQueryProjectionType]\"]\n</code></pre> <p>Apply projection parameter</p> <p>Arguments:</p> <ul> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/query/#findmanyfind","title":"FindMany.find","text":"<pre><code>def find(\n    *args: Union[Mapping[str, Any], bool],\n    projection_model: Optional[Type[FindQueryProjectionType]] = None,\n    skip: Optional[int] = None,\n    limit: Optional[int] = None,\n    sort: Union[None, str, List[Tuple[str, SortDirection]]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    fetch_links: bool = False,\n    lazy_parse: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[\"FindMany[FindQueryResultType]\",\n           \"FindMany[FindQueryProjectionType]\"]\n</code></pre> <p>The same as <code>find_many(...)</code></p> <p></p>"},{"location":"api-documentation/query/#findmanysort","title":"FindMany.sort","text":"<pre><code>def sort(\n    *args: Optional[Union[str, Tuple[str, SortDirection],\n                          List[Tuple[str, SortDirection]]]]\n) -&gt; \"FindMany[FindQueryResultType]\"\n</code></pre> <p>Add sort parameters</p> <p>Arguments:</p> <ul> <li><code>args</code>: Union[str, Tuple[str, SortDirection], List[Tuple[str, SortDirection]]] - A key or a tuple (key, direction) or a list of (key, direction) pairs specifying the sort order for this query.</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/query/#findmanyskip","title":"FindMany.skip","text":"<pre><code>def skip(n: Optional[int]) -&gt; \"FindMany[FindQueryResultType]\"\n</code></pre> <p>Set skip parameter</p> <p>Arguments:</p> <ul> <li><code>n</code>: int</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/query/#findmanylimit","title":"FindMany.limit","text":"<pre><code>def limit(n: Optional[int]) -&gt; \"FindMany[FindQueryResultType]\"\n</code></pre> <p>Set limit parameter</p> <p>Arguments:</p> <ul> <li><code>n</code>: int</li> </ul> <p></p>"},{"location":"api-documentation/query/#findmanyupdate","title":"FindMany.update","text":"<pre><code>def update(*args: Mapping[str, Any],\n           session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           **pymongo_kwargs)\n</code></pre> <p>Create Update with modifications query</p> <p>and provide search criteria there</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str,Any] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>bulk_writer</code>: Optional[BulkWriter]</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#findmanyupsert","title":"FindMany.upsert","text":"<pre><code>def upsert(*args: Mapping[str, Any],\n           on_insert: \"DocType\",\n           session: Optional[ClientSession] = None,\n           **pymongo_kwargs)\n</code></pre> <p>Create Update with modifications query</p> <p>and provide search criteria there</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str,Any] - the modifications to apply.</li> <li><code>on_insert</code>: DocType - document to insert if there is no matched document in the collection</li> <li><code>session</code>: Optional[ClientSession]</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#findmanyupdate_many","title":"FindMany.update_many","text":"<pre><code>def update_many(*args: Mapping[str, Any],\n                session: Optional[ClientSession] = None,\n                bulk_writer: Optional[BulkWriter] = None,\n                **pymongo_kwargs) -&gt; UpdateMany\n</code></pre> <p>Provide search criteria to the</p> <p>UpdateMany query</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str,Any] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#findmanydelete_many","title":"FindMany.delete_many","text":"<pre><code>def delete_many(session: Optional[ClientSession] = None,\n                bulk_writer: Optional[BulkWriter] = None,\n                **pymongo_kwargs) -&gt; DeleteMany\n</code></pre> <p>Provide search criteria to the DeleteMany query</p> <p>Arguments:</p> <ul> <li><code>session</code>: </li> </ul> <p>Returns:</p> <p>DeleteMany query</p> <p></p>"},{"location":"api-documentation/query/#findmanyaggregate","title":"FindMany.aggregate","text":"<pre><code>def aggregate(\n    aggregation_pipeline: List[Any],\n    projection_model: Optional[Type[FindQueryProjectionType]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    **pymongo_kwargs\n) -&gt; Union[\n        AggregationQuery[Dict[str, Any]],\n        AggregationQuery[FindQueryProjectionType],\n]\n</code></pre> <p>Provide search criteria to the AggregationQuery</p> <p>Arguments:</p> <ul> <li><code>aggregation_pipeline</code>: list - aggregation pipeline. MongoDB doc: https://docs.mongodb.com/manual/core/aggregation-pipeline/</li> <li><code>projection_model</code>: Type[BaseModel] - Projection Model</li> <li><code>session</code>: Optional[ClientSession] - PyMongo session</li> <li><code>ignore_cache</code>: bool</li> </ul> <p>Returns:</p> <p>AggregationQuery</p> <p></p>"},{"location":"api-documentation/query/#findmanyfirst_or_none","title":"FindMany.first_or_none","text":"<pre><code>def first_or_none() -&gt; Optional[FindQueryResultType]\n</code></pre> <p>Returns the first found element or None if no elements were found</p> <p></p>"},{"location":"api-documentation/query/#findmanycount","title":"FindMany.count","text":"<pre><code>def count() -&gt; int\n</code></pre> <p>Number of found documents</p> <p>Returns:</p> <p>int</p> <p></p>"},{"location":"api-documentation/query/#findone","title":"FindOne","text":"<pre><code>class FindOne(FindQuery[FindQueryResultType], RunInterface)\n</code></pre> <p>Find One query class</p> <p></p>"},{"location":"api-documentation/query/#findoneproject","title":"FindOne.project","text":"<pre><code>def project(\n    projection_model: Optional[Type[FindQueryProjectionType]] = None\n) -&gt; Union[\"FindOne[FindQueryResultType]\", \"FindOne[FindQueryProjectionType]\"]\n</code></pre> <p>Apply projection parameter</p> <p>Arguments:</p> <ul> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"api-documentation/query/#findonefind_one","title":"FindOne.find_one","text":"<pre><code>def find_one(\n    *args: Union[Mapping[str, Any], bool],\n    projection_model: Optional[Type[FindQueryProjectionType]] = None,\n    session: Optional[ClientSession] = None,\n    ignore_cache: bool = False,\n    fetch_links: bool = False,\n    nesting_depth: Optional[int] = None,\n    nesting_depths_per_field: Optional[Dict[str, int]] = None,\n    **pymongo_kwargs\n) -&gt; Union[\"FindOne[FindQueryResultType]\", \"FindOne[FindQueryProjectionType]\"]\n</code></pre> <p>Find one document by criteria</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str, Any] - search criteria</li> <li><code>projection_model</code>: Optional[Type[BaseModel]] - projection model</li> <li><code>session</code>: Optional[ClientSession] - pymongo session</li> <li><code>ignore_cache</code>: bool</li> <li><code>**pymongo_kwargs</code>: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)</li> </ul> <p>Returns:</p> <p>FindOne - query instance</p> <p></p>"},{"location":"api-documentation/query/#findoneupdate","title":"FindOne.update","text":"<pre><code>def update(*args: Mapping[str, Any],\n           session: Optional[ClientSession] = None,\n           bulk_writer: Optional[BulkWriter] = None,\n           response_type: Optional[UpdateResponse] = None,\n           **pymongo_kwargs)\n</code></pre> <p>Create Update with modifications query</p> <p>and provide search criteria there</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str,Any] - the modifications to apply.</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>bulk_writer</code>: Optional[BulkWriter]</li> <li><code>response_type</code>: Optional[UpdateResponse]</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#findoneupsert","title":"FindOne.upsert","text":"<pre><code>def upsert(*args: Mapping[str, Any],\n           on_insert: \"DocType\",\n           session: Optional[ClientSession] = None,\n           response_type: Optional[UpdateResponse] = None,\n           **pymongo_kwargs)\n</code></pre> <p>Create Update with modifications query</p> <p>and provide search criteria there</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str,Any] - the modifications to apply.</li> <li><code>on_insert</code>: DocType - document to insert if there is no matched document in the collection</li> <li><code>session</code>: Optional[ClientSession]</li> <li><code>response_type</code>: Optional[UpdateResponse]</li> </ul> <p>Returns:</p> <p>UpdateMany query</p> <p></p>"},{"location":"api-documentation/query/#findoneupdate_one","title":"FindOne.update_one","text":"<pre><code>def update_one(*args: Mapping[str, Any],\n               session: Optional[ClientSession] = None,\n               bulk_writer: Optional[BulkWriter] = None,\n               response_type: Optional[UpdateResponse] = None,\n               **pymongo_kwargs) -&gt; UpdateOne\n</code></pre> <p>Create UpdateOne query using modifications and</p> <p>provide search criteria there</p> <p>Arguments:</p> <ul> <li><code>args</code>: *Mapping[str,Any] - the modifications to apply</li> <li><code>session</code>: Optional[ClientSession] - PyMongo sessions</li> <li><code>response_type</code>: Optional[UpdateResponse]</li> </ul> <p>Returns:</p> <p>UpdateOne query</p> <p></p>"},{"location":"api-documentation/query/#findonedelete_one","title":"FindOne.delete_one","text":"<pre><code>def delete_one(session: Optional[ClientSession] = None,\n               bulk_writer: Optional[BulkWriter] = None,\n               **pymongo_kwargs) -&gt; DeleteOne\n</code></pre> <p>Provide search criteria to the DeleteOne query</p> <p>Arguments:</p> <ul> <li><code>session</code>: Optional[ClientSession] - PyMongo sessions</li> </ul> <p>Returns:</p> <p>DeleteOne query</p> <p></p>"},{"location":"api-documentation/query/#findonereplace_one","title":"FindOne.replace_one","text":"<pre><code>def replace_one(\n        document: \"DocType\",\n        session: Optional[ClientSession] = None,\n        bulk_writer: Optional[BulkWriter] = None) -&gt; Optional[UpdateResult]\n</code></pre> <p>Replace found document by provided</p> <p>Arguments:</p> <ul> <li><code>document</code>: Document - document, which will replace the found one</li> <li><code>session</code>: Optional[ClientSession] - PyMongo session</li> <li><code>bulk_writer</code>: Optional[BulkWriter] - bunnet bulk writer</li> </ul> <p>Returns:</p> <p>UpdateResult</p> <p></p>"},{"location":"api-documentation/query/#findonerun","title":"FindOne.run","text":"<pre><code>def run() -&gt; Optional[FindQueryResultType]\n</code></pre> <p>Run the query</p> <p>Returns:</p> <p>BaseModel</p> <p></p>"},{"location":"api-documentation/query/#findonecount","title":"FindOne.count","text":"<pre><code>def count() -&gt; int\n</code></pre> <p>Count the number of documents matching the query</p> <p>Returns:</p> <p>int</p> <p></p>"},{"location":"api-documentation/query/#bunnetodmqueriescursor","title":"bunnet.odm.queries.cursor","text":""},{"location":"api-documentation/query/#basecursorquery","title":"BaseCursorQuery","text":"<pre><code>class BaseCursorQuery(Generic[CursorResultType], RunInterface)\n</code></pre> <p>BaseCursorQuery class. Wrapper over pymongo Cursor, which parse result with model</p> <p></p>"},{"location":"api-documentation/query/#basecursorqueryto_list","title":"BaseCursorQuery.to_list","text":"<pre><code>def to_list(length: Optional[int] = None) -&gt; List[CursorResultType]\n</code></pre> <p>Get list of documents</p> <p>Arguments:</p> <ul> <li><code>length</code>: Optional[int] - length of the list</li> </ul> <p>Returns:</p> <p>Union[List[BaseModel], List[Dict[str, Any]]]</p> <p></p>"},{"location":"api-documentation/query/#bunnetodmqueriesdelete","title":"bunnet.odm.queries.delete","text":""},{"location":"api-documentation/query/#deletequery","title":"DeleteQuery","text":"<pre><code>class DeleteQuery(SessionMethods, RunInterface, CloneInterface)\n</code></pre> <p>Deletion Query</p> <p></p>"},{"location":"api-documentation/query/#deletemany","title":"DeleteMany","text":"<pre><code>class DeleteMany(DeleteQuery)\n</code></pre>"},{"location":"api-documentation/query/#deletemanyrun","title":"DeleteMany.run","text":"<pre><code>def run() -&gt; Union[DeleteResult, None, Optional[DeleteResult]]\n</code></pre> <p>Run the query </p> <p></p>"},{"location":"api-documentation/query/#deleteone","title":"DeleteOne","text":"<pre><code>class DeleteOne(DeleteQuery)\n</code></pre>"},{"location":"api-documentation/query/#deleteonerun","title":"DeleteOne.run","text":"<pre><code>def run() -&gt; Union[DeleteResult, None, Optional[DeleteResult]]\n</code></pre> <p>Run the query </p>"},{"location":"api-documentation/operators/find/","title":"Find","text":""},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindlogical","title":"bunnet.odm.operators.find.logical","text":""},{"location":"api-documentation/operators/find/#or","title":"Or","text":"<pre><code>class Or(LogicalOperatorForListOfExpressions)\n</code></pre> <p><code>$or</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n    category: str\n\nOr(Product.price&lt;10, Product.category==\"Sweets\")\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$or\": [{\"price\": {\"$lt\": 10}}, {\"category\": \"Sweets\"}]}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/or/</p> <p></p>"},{"location":"api-documentation/operators/find/#and","title":"And","text":"<pre><code>class And(LogicalOperatorForListOfExpressions)\n</code></pre> <p><code>$and</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n    category: str\n\nAnd(Product.price&lt;10, Product.category==\"Sweets\")\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$and\": [{\"price\": {\"$lt\": 10}}, {\"category\": \"Sweets\"}]}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/and/</p> <p></p>"},{"location":"api-documentation/operators/find/#nor","title":"Nor","text":"<pre><code>class Nor(BaseFindLogicalOperator)\n</code></pre> <p><code>$nor</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n    category: str\n\nNor(Product.price&lt;10, Product.category==\"Sweets\")\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$nor\": [{\"price\": {\"$lt\": 10}}, {\"category\": \"Sweets\"}]}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/nor/</p> <p></p>"},{"location":"api-documentation/operators/find/#not","title":"Not","text":"<pre><code>class Not(BaseFindLogicalOperator)\n</code></pre> <p><code>$not</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n    category: str\n\nNot(Product.price&lt;10)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$not\": {\"price\": {\"$lt\": 10}}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/not/</p> <p></p>"},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindarray","title":"bunnet.odm.operators.find.array","text":""},{"location":"api-documentation/operators/find/#all","title":"All","text":"<pre><code>class All(BaseFindArrayOperator)\n</code></pre> <p><code>$all</code> array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nAll(Sample.results, [80, 85])\n</code></pre> <p>Will return query object like</p> <pre><code>{\"results\": {\"$all\": [80, 85]}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/all</p> <p></p>"},{"location":"api-documentation/operators/find/#elemmatch","title":"ElemMatch","text":"<pre><code>class ElemMatch(BaseFindArrayOperator)\n</code></pre> <p><code>$elemMatch</code> array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nElemMatch(Sample.results, {\"$in\": [80, 85]})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"results\": {\"$elemMatch\": {\"$in\": [80, 85]}}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/elemMatch/</p> <p></p>"},{"location":"api-documentation/operators/find/#size","title":"Size","text":"<pre><code>class Size(BaseFindArrayOperator)\n</code></pre> <p><code>$size</code> array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nSize(Sample.results, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"results\": {\"$size\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/size/</p> <p></p>"},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindevaluation","title":"bunnet.odm.operators.find.evaluation","text":""},{"location":"api-documentation/operators/find/#expr","title":"Expr","text":"<pre><code>class Expr(BaseFindEvaluationOperator)\n</code></pre> <p><code>$type</code> query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n    two: int\n\nExpr({\"$gt\": [ \"$one\" , \"$two\" ]})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$expr\": {\"$gt\": [ \"$one\" , \"$two\" ]}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/expr/</p> <p></p>"},{"location":"api-documentation/operators/find/#jsonschema","title":"JsonSchema","text":"<pre><code>class JsonSchema(BaseFindEvaluationOperator)\n</code></pre> <p><code>$jsonSchema</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/</p> <p></p>"},{"location":"api-documentation/operators/find/#mod","title":"Mod","text":"<pre><code>class Mod(BaseFindEvaluationOperator)\n</code></pre> <p><code>$mod</code> query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nMod(Sample.one, 4, 0)\n</code></pre> <p>Will return query object like</p> <pre><code>{ \"one\": { \"$mod\": [ 4, 0 ] } }\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/mod/</p> <p></p>"},{"location":"api-documentation/operators/find/#regex","title":"RegEx","text":"<pre><code>class RegEx(BaseFindEvaluationOperator)\n</code></pre> <p><code>$regex</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/regex/</p> <p></p>"},{"location":"api-documentation/operators/find/#text","title":"Text","text":"<pre><code>class Text(BaseFindEvaluationOperator)\n</code></pre> <p><code>$text</code> query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    description: Indexed(str, pymongo.TEXT)\n\nText(\"coffee\")\n</code></pre> <p>Will return query object like</p> <pre><code>{\n    \"$text\": {\n        \"$search\": \"coffee\" ,\n        \"$caseSensitive\": False,\n        \"$diacriticSensitive\": False\n    }\n}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/text/</p> <p></p>"},{"location":"api-documentation/operators/find/#text__init__","title":"Text.__init__","text":"<pre><code>def __init__(search: str,\n             language: Optional[str] = None,\n             case_sensitive: bool = False,\n             diacritic_sensitive: bool = False)\n</code></pre> <p>Arguments:</p> <ul> <li><code>search</code>: str</li> <li><code>language</code>: Optional[str] = None</li> <li><code>case_sensitive</code>: bool = False</li> <li><code>diacritic_sensitive</code>: bool = False</li> </ul> <p></p>"},{"location":"api-documentation/operators/find/#where","title":"Where","text":"<pre><code>class Where(BaseFindEvaluationOperator)\n</code></pre> <p><code>$where</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/where/</p> <p></p>"},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindelement","title":"bunnet.odm.operators.find.element","text":""},{"location":"api-documentation/operators/find/#exists","title":"Exists","text":"<pre><code>class Exists(BaseFindElementOperator)\n</code></pre> <p><code>$exists</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nExists(Product.price, True)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$exists\": True}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/exists/</p> <p></p>"},{"location":"api-documentation/operators/find/#type","title":"Type","text":"<pre><code>class Type(BaseFindElementOperator)\n</code></pre> <p><code>$type</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nType(Product.price, \"decimal\")\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$type\": \"decimal\"}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/type/</p> <p></p>"},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindcomparison","title":"bunnet.odm.operators.find.comparison","text":""},{"location":"api-documentation/operators/find/#eq","title":"Eq","text":"<pre><code>class Eq(BaseFindComparisonOperator)\n</code></pre> <p><code>equal</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nEq(Product.price, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": 2}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/eq/</p> <p></p>"},{"location":"api-documentation/operators/find/#gt","title":"GT","text":"<pre><code>class GT(BaseFindComparisonOperator)\n</code></pre> <p><code>$gt</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nGT(Product.price, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$gt\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/gt/</p> <p></p>"},{"location":"api-documentation/operators/find/#gte","title":"GTE","text":"<pre><code>class GTE(BaseFindComparisonOperator)\n</code></pre> <p><code>$gte</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nGTE(Product.price, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$gte\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/gte/</p> <p></p>"},{"location":"api-documentation/operators/find/#in","title":"In","text":"<pre><code>class In(BaseFindComparisonOperator)\n</code></pre> <p><code>$in</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nIn(Product.price, [2, 3, 4])\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$in\": [2, 3, 4]}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/in/</p> <p></p>"},{"location":"api-documentation/operators/find/#notin","title":"NotIn","text":"<pre><code>class NotIn(BaseFindComparisonOperator)\n</code></pre> <p><code>$nin</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nNotIn(Product.price, [2, 3, 4])\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$nin\": [2, 3, 4]}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/nin/</p> <p></p>"},{"location":"api-documentation/operators/find/#lt","title":"LT","text":"<pre><code>class LT(BaseFindComparisonOperator)\n</code></pre> <p><code>$lt</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nLT(Product.price, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$lt\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/lt/</p> <p></p>"},{"location":"api-documentation/operators/find/#lte","title":"LTE","text":"<pre><code>class LTE(BaseFindComparisonOperator)\n</code></pre> <p><code>$lte</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nLTE(Product.price, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$lte\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/lte/</p> <p></p>"},{"location":"api-documentation/operators/find/#ne","title":"NE","text":"<pre><code>class NE(BaseFindComparisonOperator)\n</code></pre> <p><code>$ne</code> query operator</p> <p>Example:</p> <pre><code>class Product(Document):\n    price: float\n\nNE(Product.price, 2)\n</code></pre> <p>Will return query object like</p> <pre><code>{\"price\": {\"$ne\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/ne/</p> <p></p>"},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindgeospatial","title":"bunnet.odm.operators.find.geospatial","text":""},{"location":"api-documentation/operators/find/#geointersects","title":"GeoIntersects","text":"<pre><code>class GeoIntersects(BaseFindGeospatialOperator)\n</code></pre> <p><code>$geoIntersects</code> query operator</p> <p>Example:</p> <pre><code>class GeoObject(BaseModel):\n    type: str = \"Point\"\n    coordinates: Tuple[float, float]\n\nclass Place(Document):\n    geo: GeoObject\n\n    class Collection:\n        name = \"places\"\n        indexes = [\n            [(\"geo\", pymongo.GEOSPHERE)],  # GEO index\n        ]\n\nGeoIntersects(Place.geo, \"Polygon\", [[0,0], [1,1], [3,3]])\n</code></pre> <p>Will return query object like</p> <pre><code>{\n    \"geo\": {\n        \"$geoIntersects\": {\n            \"$geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [[0,0], [1,1], [3,3]],\n            }\n        }\n    }\n}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/geoIntersects/</p> <p></p>"},{"location":"api-documentation/operators/find/#geowithin","title":"GeoWithin","text":"<pre><code>class GeoWithin(BaseFindGeospatialOperator)\n</code></pre> <p><code>$geoWithin</code> query operator</p> <p>Example:</p> <pre><code>class GeoObject(BaseModel):\n    type: str = \"Point\"\n    coordinates: Tuple[float, float]\n\nclass Place(Document):\n    geo: GeoObject\n\n    class Collection:\n        name = \"places\"\n        indexes = [\n            [(\"geo\", pymongo.GEOSPHERE)],  # GEO index\n        ]\n\nGeoWithin(Place.geo, \"Polygon\", [[0,0], [1,1], [3,3]])\n</code></pre> <p>Will return query object like</p> <pre><code>{\n    \"geo\": {\n        \"$geoWithin\": {\n            \"$geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [[0,0], [1,1], [3,3]],\n            }\n        }\n    }\n}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/geoWithin/</p> <p></p>"},{"location":"api-documentation/operators/find/#box","title":"Box","text":"<pre><code>class Box(BaseFindGeospatialOperator)\n</code></pre> <p><code>$box</code> query operator</p> <p>Example:</p> <pre><code>class GeoObject(BaseModel):\n    type: str = \"Point\"\n    coordinates: Tuple[float, float]\n\nclass Place(Document):\n    geo: GeoObject\n\n    class Collection:\n        name = \"places\"\n        indexes = [\n            [(\"geo\", pymongo.GEOSPHERE)],  # GEO index\n        ]\n\nBox(Place.geo, lower_left=[10,12], upper_right=[15,20])\n</code></pre> <p>Will return query object like</p> <pre><code>{\n    \"geo\": {\n        \"$geoWithin\": {\n            \"$box\": [[10, 12], [15, 20]]\n        }\n    }\n}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/box/</p> <p></p>"},{"location":"api-documentation/operators/find/#near","title":"Near","text":"<pre><code>class Near(BaseFindGeospatialOperator)\n</code></pre> <p><code>$near</code> query operator</p> <p>Example:</p> <pre><code>class GeoObject(BaseModel):\n    type: str = \"Point\"\n    coordinates: Tuple[float, float]\n\nclass Place(Document):\n    geo: GeoObject\n\n    class Collection:\n        name = \"places\"\n        indexes = [\n            [(\"geo\", pymongo.GEOSPHERE)],  # GEO index\n        ]\n\nNear(Place.geo, 1.2345, 2.3456, min_distance=500)\n</code></pre> <p>Will return query object like</p> <pre><code>{\n    \"geo\": {\n        \"$near\": {\n            \"$geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [1.2345, 2.3456],\n            },\n            \"$maxDistance\": 500,\n        }\n    }\n}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/near/</p> <p></p>"},{"location":"api-documentation/operators/find/#nearsphere","title":"NearSphere","text":"<pre><code>class NearSphere(Near)\n</code></pre> <p><code>$nearSphere</code> query operator</p> <p>Example:</p> <pre><code>class GeoObject(BaseModel):\n    type: str = \"Point\"\n    coordinates: Tuple[float, float]\n\nclass Place(Document):\n    geo: GeoObject\n\n    class Collection:\n        name = \"places\"\n        indexes = [\n            [(\"geo\", pymongo.GEOSPHERE)],  # GEO index\n        ]\n\nNearSphere(Place.geo, 1.2345, 2.3456, min_distance=500)\n</code></pre> <p>Will return query object like</p> <pre><code>{\n    \"geo\": {\n        \"$nearSphere\": {\n            \"$geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [1.2345, 2.3456],\n            },\n            \"$maxDistance\": 500,\n        }\n    }\n}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/query/nearSphere/</p> <p></p>"},{"location":"api-documentation/operators/find/#bunnetodmoperatorsfindbitwise","title":"bunnet.odm.operators.find.bitwise","text":""},{"location":"api-documentation/operators/find/#bitsallclear","title":"BitsAllClear","text":"<pre><code>class BitsAllClear(BaseFindBitwiseOperator)\n</code></pre> <p><code>$bitsAllClear</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAllClear/</p> <p></p>"},{"location":"api-documentation/operators/find/#bitsallset","title":"BitsAllSet","text":"<pre><code>class BitsAllSet(BaseFindBitwiseOperator)\n</code></pre> <p><code>$bitsAllSet</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAllSet/</p> <p></p>"},{"location":"api-documentation/operators/find/#bitsanyclear","title":"BitsAnyClear","text":"<pre><code>class BitsAnyClear(BaseFindBitwiseOperator)\n</code></pre> <p><code>$bitsAnyClear</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAnyClear/</p> <p></p>"},{"location":"api-documentation/operators/find/#bitsanyset","title":"BitsAnySet","text":"<pre><code>class BitsAnySet(BaseFindBitwiseOperator)\n</code></pre> <p><code>$bitsAnySet</code> query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAnySet/</p>"},{"location":"api-documentation/operators/update/","title":"Update","text":""},{"location":"api-documentation/operators/update/#bunnetodmoperatorsupdatearray","title":"bunnet.odm.operators.update.array","text":""},{"location":"api-documentation/operators/update/#addtoset","title":"AddToSet","text":"<pre><code>class AddToSet(BaseUpdateArrayOperator)\n</code></pre> <p><code>$addToSet</code> update array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nAddToSet({Sample.results: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$addToSet\": {\"results\": 2}}\n</code></pre> <p>MongoDB docs:   https://docs.mongodb.com/manual/reference/operator/update/addToSet/</p> <p></p>"},{"location":"api-documentation/operators/update/#pop","title":"Pop","text":"<pre><code>class Pop(BaseUpdateArrayOperator)\n</code></pre> <p><code>$pop</code> update array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nPop({Sample.results: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$pop\": {\"results\": -1}}\n</code></pre> <p>MongoDB docs:   https://docs.mongodb.com/manual/reference/operator/update/pop/</p> <p></p>"},{"location":"api-documentation/operators/update/#pull","title":"Pull","text":"<pre><code>class Pull(BaseUpdateArrayOperator)\n</code></pre> <p><code>$pull</code> update array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nPull(In(Sample.result: [1,2,3,4,5])\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$pull\": { \"results\": { $in: [1,2,3,4,5] }}}\n</code></pre> <p>MongoDB docs:   https://docs.mongodb.com/manual/reference/operator/update/pull/</p> <p></p>"},{"location":"api-documentation/operators/update/#push","title":"Push","text":"<pre><code>class Push(BaseUpdateArrayOperator)\n</code></pre> <p><code>$push</code> update array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nPush({Sample.results: 1})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$push\": { \"results\": 1}}\n</code></pre> <p>MongoDB docs:   https://docs.mongodb.com/manual/reference/operator/update/push/</p> <p></p>"},{"location":"api-documentation/operators/update/#pullall","title":"PullAll","text":"<pre><code>class PullAll(BaseUpdateArrayOperator)\n</code></pre> <p><code>$pullAll</code> update array query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    results: List[int]\n\nPullAll({ Sample.results: [ 0, 5 ] })\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$pullAll\": { \"results\": [ 0, 5 ] }}\n</code></pre> <p>MongoDB docs:   https://docs.mongodb.com/manual/reference/operator/update/pullAll/</p> <p></p>"},{"location":"api-documentation/operators/update/#bunnetodmoperatorsupdategeneral","title":"bunnet.odm.operators.update.general","text":""},{"location":"api-documentation/operators/update/#set","title":"Set","text":"<pre><code>class Set(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$set</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nSet({Sample.one: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$set\": {\"one\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/set/</p> <p></p>"},{"location":"api-documentation/operators/update/#setrevisionid","title":"SetRevisionId","text":"<pre><code>class SetRevisionId()\n</code></pre> <p><code>$set</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nSet({Sample.one: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$set\": {\"one\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/set/</p> <p></p>"},{"location":"api-documentation/operators/update/#currentdate","title":"CurrentDate","text":"<pre><code>class CurrentDate(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$currentDate</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    ts: datetime\n\nCurrentDate({Sample.ts: True})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$currentDate\": {\"ts\": True}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/currentDate/</p> <p></p>"},{"location":"api-documentation/operators/update/#inc","title":"Inc","text":"<pre><code>class Inc(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$inc</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nInc({Sample.one: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$inc\": {\"one\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/inc/</p> <p></p>"},{"location":"api-documentation/operators/update/#min","title":"Min","text":"<pre><code>class Min(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$min</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nMin({Sample.one: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$min\": {\"one\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/min/</p> <p></p>"},{"location":"api-documentation/operators/update/#max","title":"Max","text":"<pre><code>class Max(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$max</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nMax({Sample.one: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$max\": {\"one\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/max/</p> <p></p>"},{"location":"api-documentation/operators/update/#mul","title":"Mul","text":"<pre><code>class Mul(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$mul</code> update query operator</p> <p>Example:</p> <pre><code>class Sample(Document):\n    one: int\n\nMul({Sample.one: 2})\n</code></pre> <p>Will return query object like</p> <pre><code>{\"$mul\": {\"one\": 2}}\n</code></pre> <p>MongoDB doc:   https://docs.mongodb.com/manual/reference/operator/update/mul/</p> <p></p>"},{"location":"api-documentation/operators/update/#rename","title":"Rename","text":"<pre><code>class Rename(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$rename</code> update query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/rename/</p> <p></p>"},{"location":"api-documentation/operators/update/#setoninsert","title":"SetOnInsert","text":"<pre><code>class SetOnInsert(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$setOnInsert</code> update query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/</p> <p></p>"},{"location":"api-documentation/operators/update/#unset","title":"Unset","text":"<pre><code>class Unset(BaseUpdateGeneralOperator)\n</code></pre> <p><code>$unset</code> update query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/unset/</p> <p></p>"},{"location":"api-documentation/operators/update/#bunnetodmoperatorsupdatebitwise","title":"bunnet.odm.operators.update.bitwise","text":""},{"location":"api-documentation/operators/update/#bit","title":"Bit","text":"<pre><code>class Bit(BaseUpdateBitwiseOperator)\n</code></pre> <p><code>$bit</code> update query operator</p> <p>MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/bit/</p>"},{"location":"tutorial/aggregation/","title":"Aggregations","text":"<p>You can perform aggregation queries through bunnet as well. For example, to calculate the average:</p> <pre><code># With a search:\navg_price = Product.find(\n    Product.category.name == \"Chocolate\"\n).avg(Product.price)\n\n# Over the whole collection:\navg_price = Product.avg(Product.price)\n</code></pre> <p>A full list of available methods can be found here.</p> <p>You can also use the native PyMongo syntax by calling the <code>aggregate</code> method.  However, as Bunnet will not know what output to expect, you will have to supply a projection model yourself.  If you do not supply a projection model, then a dictionary will be returned.</p> <pre><code>class OutputItem(BaseModel):\n    id: str = Field(None, alias=\"_id\")\n    total: float\n\n\nresult = Product.find(\n    Product.category.name == \"Chocolate\").aggregate(\n    [{\"$group\": {\"_id\": \"$category.name\", \"total\": {\"$avg\": \"$price\"}}}],\n    projection_model=OutputItem\n).to_list()\n</code></pre>"},{"location":"tutorial/cache/","title":"Cache","text":"<p>All query results could be locally cached.</p> <p>This feature must be explicitly turned on in the <code>Settings</code> inner class.</p> <pre><code>from bunnet import Document\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    class Settings:\n        use_cache = True\n</code></pre> <p>Bunnet uses LRU cache with expiration time.  You can set <code>capacity</code> (the maximum number of the cached queries) and expiration time in the <code>Settings</code> inner class.</p> <pre><code>from bunnet import Document\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    class Settings:\n        use_cache = True\n        cache_expiration_time = datetime.timedelta(seconds=10)\n        cache_capacity = 5\n</code></pre> <p>Any query will be cached for this document class.</p> <pre><code># on the first call it will go to the database\nsamples = Sample.find(num&gt;10).to_list()\n\n# on the second - it will use cache instead\nsamples = Sample.find(num&gt;10).to_list()\n\nsleep(15)\n\n# if the expiration time was reached it will go to the database again\nsamples = Sample.find(num&gt;10).to_list()\n</code></pre>"},{"location":"tutorial/defining-a-document/","title":"Defining a document","text":"<p>The <code>Document</code> class in Bunnet is responsible for mapping and handling the data from the collection. It is inherited from the <code>BaseModel</code> Pydantic class, so it follows the same data typing and parsing behavior.</p> <pre><code>from typing import Optional\n\nimport pymongo\nfrom pydantic import BaseModel\n\nfrom bunnet import Document\nfrom bunnet import Indexed\n\n\nclass Category(BaseModel):\n    name: str\n    description: str\n\n\nclass Product(Document):  # This is the model\n    name: str\n    description: Optional[str] = None\n    price: Indexed(float, pymongo.DESCENDING)\n    category: Category\n\n    class Settings:\n        name = \"products\"\n        indexes = [\n            [\n                (\"name\", pymongo.TEXT),\n                (\"description\", pymongo.TEXT),\n            ],\n        ]\n</code></pre>"},{"location":"tutorial/defining-a-document/#fields","title":"Fields","text":"<p>As it was mentioned before, the <code>Document</code> class is inherited from the Pydantic <code>BaseModel</code> class.  It uses all the same patterns of <code>BaseModel</code>. But also it has special types of fields:</p> <ul> <li>id</li> <li>Indexed</li> </ul>"},{"location":"tutorial/defining-a-document/#id","title":"id","text":"<p><code>id</code> field of the <code>Document</code> class reflects the unique <code>_id</code> field of the MongoDB document.  Each object of the <code>Document</code> type has this field.  The default type of this is PydanticObjectId.</p> <pre><code>from bunnet import Document\n\nclass Sample(Document):\n    num: int\n    description: str\n\nfoo = Sample.find_one(Sample.num &gt; 5).run()\n\nprint(foo.id)  # This will print id\n\nbar = Sample.get(foo.id).run()  # get by id\n</code></pre> <p>If you prefer another type, you can set it up too. For example, UUID:</p> <pre><code>from uuid import UUID, uuid4\n\nfrom pydantic import Field\n\nfrom bunnet import Document\n\n\nclass Sample(Document):\n    id: UUID = Field(default_factory=uuid4)\n    num: int\n    description: str\n</code></pre>"},{"location":"tutorial/defining-a-document/#indexed","title":"Indexed","text":"<p>To set up an index over a single field, the <code>Indexed</code> function can be used to wrap the type:</p> <pre><code>from bunnet import Indexed\nfrom bunnet import Document\n\n\nclass Sample(Document):\n    num: Indexed(int)\n    description: str\n</code></pre> <p>The <code>Indexed</code> function takes an optional argument <code>index_type</code>, which may be set to a pymongo index type:</p> <pre><code>from bunnet import Document\nfrom bunnet import Indexed\n\nimport pymongo\n\nclass Sample(Document):\n    description: Indexed(str, index_type=pymongo.TEXT)\n</code></pre> <p>The <code>Indexed</code> function also supports pymongo <code>IndexModel</code> kwargs arguments (PyMongo Documentation). </p> <p>For example, to create a <code>unique</code> index:</p> <pre><code>from bunnet import Document\nfrom bunnet import Indexed\n\nclass Sample(Document):\n    name: Indexed(str, unique=True)\n</code></pre>"},{"location":"tutorial/defining-a-document/#settings","title":"Settings","text":"<p>The inner class <code>Settings</code> is used to configure:</p> <ul> <li>MongoDB collection name</li> <li>Indexes</li> <li>Encoders</li> <li>Use of <code>revision_id</code></li> <li>Use of cache</li> <li>Use of state management</li> <li>Validation on save</li> <li>Configure if nulls should be saved to the database</li> </ul>"},{"location":"tutorial/defining-a-document/#collection-name","title":"Collection name","text":"<p>To set MongoDB collection name, you can use the <code>name</code> field of the <code>Settings</code> inner class.</p> <pre><code>from bunnet import Document\n\nclass Sample(Document):\n    num: int\n    description: str\n\n    class Settings:\n        name = \"samples\"\n</code></pre>"},{"location":"tutorial/defining-a-document/#indexes","title":"Indexes","text":"<p>The <code>indexes</code> field of the inner <code>Settings</code> class is responsible for the indexes' setup.  It is a list where items can be:</p> <ul> <li>Single key. Name of the document's field (this is equivalent to using the Indexed function described above)</li> <li>List of (key, direction) pairs. Key - string, name of the document's field. Direction - pymongo direction (   example: <code>pymongo.ASCENDING</code>)</li> <li><code>pymongo.IndexModel</code> instance - the most flexible   option. PyMongo Documentation</li> </ul> <pre><code>from bunnet import Document\n\nclass DocumentTestModelWithIndex(Document):\n    test_int: int\n    test_list: List[SubDocument]\n    test_str: str\n\n    class Settings:\n        indexes = [\n            \"test_int\",\n            [\n                (\"test_int\", pymongo.ASCENDING),\n                (\"test_str\", pymongo.DESCENDING),\n            ],\n            IndexModel(\n                [(\"test_str\", pymongo.DESCENDING)],\n                name=\"test_string_index_DESCENDING\",\n            ),\n        ]\n</code></pre>"},{"location":"tutorial/defining-a-document/#encoders","title":"Encoders","text":"<p>The <code>bson_encoders</code> field of the inner <code>Settings</code> class defines how the Python types are going to be represented  when saved in the database. The default conversions can be overridden with this.</p> <p>The <code>ip</code> field in the following example is converted to String by default:</p> <pre><code>from ipaddress import IPv4Address\n\nfrom bunnet import Document\n\n\nclass Sample(Document):\n    ip: IPv4Address\n</code></pre> <p>Note: Default conversions are defined in <code>bunnet.odm.utils.bson.ENCODERS_BY_TYPE</code>.</p> <p>However, if you want the <code>ip</code> field to be represented as Integer in the database,  you need to override the default encoders like this:</p> <pre><code>from ipaddress import IPv4Address\n\nfrom bunnet import Document\n\nclass Sample(Document):\n    ip: IPv4Address\n\n    class Settings:\n        bson_encoders = {\n          IPv4Address: int\n        }\n</code></pre> <p>You can also define your own function for the encoding:</p> <pre><code>from ipaddress import IPv4Address\n\nfrom bunnet import Document\n\ndef ipv4address_to_int(v: IPv4Address):\n    return int(v)\n\nclass Sample(Document):\n    ip: IPv4Address\n\n    class Settings:\n        bson_encoders = {\n          IPv4Address: ipv4address_to_int\n        }\n</code></pre>"},{"location":"tutorial/defining-a-document/#keep-nulls","title":"Keep nulls","text":"<p>By default, Bunnet saves fields with <code>None</code> value as <code>null</code> in the database.</p> <p>But if you don't want to save <code>null</code> values, you can set <code>keep_nulls</code> to <code>False</code> in the <code>Settings</code> class:</p> <pre><code>class Sample(Document):\n    num: int\n    description: Optional[str] = None\n\n    class Settings:\n        keep_nulls = False\n</code></pre>"},{"location":"tutorial/event-based-actions/","title":"Event-based actions","text":"<p>You can register methods as pre- or post- actions for document events.</p> <p>Currently supported events:</p> <ul> <li>Insert</li> <li>Replace</li> <li>Update</li> <li>SaveChanges</li> <li>Delete</li> <li>ValidateOnSave</li> </ul> <p>Currently supported directions:</p> <ul> <li><code>Before</code></li> <li><code>After</code></li> </ul> <p>Current operations creating events:</p> <ul> <li><code>insert()</code> for Insert</li> <li><code>replace()</code> for Replace</li> <li><code>save()</code> triggers Insert if it is creating a new document, triggers Replace if it replaces an existing document</li> <li><code>save_changes()</code> for SaveChanges</li> <li><code>insert()</code>, <code>replace()</code>, <code>save_changes()</code>, and <code>save()</code> for ValidateOnSave</li> <li><code>set()</code>, <code>update()</code> for Update</li> <li><code>delete()</code> for Delete</li> </ul> <p>To register an action, you can use <code>@before_event</code> and <code>@after_event</code> decorators respectively:</p> <pre><code>from bunnet import Document, before_event, after_event, Insert, Replace\n\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    @before_event(Insert)\n    def capitalize_name(self):\n        self.name = self.name.capitalize()\n\n    @after_event(Replace)\n    def num_change(self):\n        self.num -= 1\n</code></pre> <p>It is possible to register action for several events:</p> <pre><code>from bunnet import Document, before_event, Insert, Replace\n\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    @before_event(Insert, Replace)\n    def capitalize_name(self):\n        self.name = self.name.capitalize()\n</code></pre> <p>This will capitalize the <code>name</code> field value before each document's Insert and Replace.</p> <p>Actions can be selectively skipped by passing the <code>skip_actions</code> argument when calling the operations that trigger events. <code>skip_actions</code> accepts a list of directions and action names.</p> <pre><code>from bunnet import Document, before_event, after_event, After, Before, Insert, Replace\n\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    @before_event(Insert)\n    def capitalize_name(self):\n        self.name = self.name.capitalize()\n\n    @before_event(Replace)\n    def redact_name(self):\n        self.name = \"[REDACTED]\"\n\n    @after_event(Replace)\n    def num_change(self):\n        self.num -= 1\n\n\nsample = Sample()\n\n# capitalize_name will not be executed\nsample.insert(skip_actions=['capitalize_name'])\n\n# num_change will not be executed\nsample.replace(skip_actions=[After])\n\n# redact_name and num_change will not be executed\nsample.replace(skip_actions=[Before, 'num_change'])\n</code></pre>"},{"location":"tutorial/finding-documents/","title":"Finding documents","text":"<p>To populate the database, please run the examples from the previous section of the tutorial  as we will be using the same setup here.</p>"},{"location":"tutorial/finding-documents/#finding-documents","title":"Finding documents","text":"<p>The basic syntax for finding multiple documents in the database is to call the class method <code>find()</code>  or it's synonym <code>find_many()</code> with some search criteria (see next section): </p> <pre><code>findresult = Product.find(search_criteria)\n</code></pre> <p>This returns a <code>FindMany</code> object, which can be used to access the results in different ways.  To loop through the results, use a <code>for</code> loop:</p> <pre><code>for result in Product.find(search_criteria):\n    print(result)\n</code></pre> <p>If you prefer a list of the results, then you can call <code>to_list()</code> method:</p> <pre><code>result = Product.find(search_criteria).to_list()\n</code></pre> <p>To get the first document, you can use <code>.first_or_none()</code> method.  It returns the first found document or <code>None</code>, if no documents were found.</p> <pre><code>result = Product.find(search_criteria).first_or_none()\n</code></pre>"},{"location":"tutorial/finding-documents/#search-criteria","title":"Search criteria","text":"<p>As search criteria, Bunnet supports Python-based syntax. For comparisons Python comparison operators can be used on the class fields (and nested fields):</p> <pre><code>products = Product.find(Product.price &lt; 10).to_list()\n</code></pre> <p>This is supported for the following operators: <code>==</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code>. Other MongoDB query operators can be used with the included wrappers.  For example, the <code>$in</code> operator can be used as follows:</p> <pre><code>from bunnet.operators import In\n\nproducts = Product.find(\n    In(Product.category.name, [\"Chocolate\", \"Fruits\"])\n).to_list()\n</code></pre> <p>The whole list of the find query operators can be found here.</p> <p>For more complex cases native PyMongo syntax is also supported:</p> <pre><code>products = Product.find({\"price\": 1000}).to_list()\n</code></pre>"},{"location":"tutorial/finding-documents/#finding-single-documents","title":"Finding single documents","text":"<p>Sometimes you will only need to find a single document.  If you are searching by <code>id</code>, then you can use the get method:</p> <pre><code>bar = Product.get(\"608da169eb9e17281f0ab2ff\").run()\n</code></pre> <p>To find a single document via a single search criterion, you can use the find_one method:</p> <pre><code>bar = ~Product.get(\"608da169eb9e17281f0ab2ff\")\n</code></pre> <p>The <code>~</code> prefix can replace <code>run</code> methods of any query here and later.</p> <p>To find a single document via a searching criteria, you can use the find_one method:</p> <pre><code>bar = Product.find_one(Product.name == \"Peanut Bar\").run()\n</code></pre>"},{"location":"tutorial/finding-documents/#more-complex-queries","title":"More complex queries","text":""},{"location":"tutorial/finding-documents/#multiple-search-criteria","title":"Multiple search criteria","text":"<p>If you have multiple criteria to search against,  you can pass them as separate arguments to any of the <code>find</code> functions:</p> <pre><code>chocolates = Product.find(\n    Product.category.name == \"Chocolate\",\n    Product.price &lt; 5\n).to_list()\n</code></pre> <p>Alternatively, you can chain <code>find</code> methods:</p> <pre><code>chocolates = Product\n              .find(Product.category.name == \"Chocolate\")\n              .find(Product.price &lt; 5).to_list()\n</code></pre>"},{"location":"tutorial/finding-documents/#sorting","title":"Sorting","text":"<p>Sorting can be done with the sort method.</p> <p>You can pass it one or multiple fields to sort by. You may optionally specify a <code>+</code> or <code>-</code>  (denoting ascending and descending respectively).</p> <pre><code>chocolates = Product.find(\n    Product.category.name == \"Chocolate\").sort(-Product.price,+Product.name).to_list()\n</code></pre> <p>You can also specify fields as strings or as tuples:</p> <pre><code>chocolates = Product.find(\n    Product.category.name == \"Chocolate\").sort(\"-price\",\"+name\").to_list()\n\nchocolates = Product.find(\n    Product.category.name == \"Chocolate\").sort(\n    [\n        (Product.price, pymongo.DESCENDING),\n        (Product.name, pymongo.ASCENDING),\n    ]\n).to_list()\n</code></pre>"},{"location":"tutorial/finding-documents/#skip-and-limit","title":"Skip and limit","text":"<p>To skip a certain number of documents, or limit the total number of elements returned,  the <code>skip</code> and <code>limit</code> methods can be used: <pre><code>chocolates = Product.find(\n    Product.category.name == \"Chocolate\").skip(2).to_list()\n\nchocolates = Product.find(\n    Product.category.name == \"Chocolate\").limit(2).to_list()\n</code></pre></p>"},{"location":"tutorial/finding-documents/#projections","title":"Projections","text":"<p>When only a part of a document is required, projections can save a lot of database bandwidth and processing. For simple projections we can just define a pydantic model with the required fields and pass it to <code>project()</code> method:</p> <pre><code>class ProductShortView(BaseModel):\n    name: str\n    price: float\n\n\nchocolates = Product.find(\n    Product.category.name == \"Chocolate\").project(ProductShortView).to_list()\n</code></pre> <p>For more complex projections an inner <code>Settings</code> class with a <code>projection</code> field can be added:</p> <pre><code>class ProductView(BaseModel):\n    name: str\n    category: str\n\n    class Settings:\n        projection = {\"name\": 1, \"category\": \"$category.name\"}\n\n\nchocolates = Product.find(\n    Product.category.name == \"Chocolate\").project(ProductView).to_list()\n</code></pre>"},{"location":"tutorial/finding-documents/#finding-all-documents","title":"Finding all documents","text":"<p>If you ever want to find all documents, you can use the <code>find_all()</code> class method. This is equivalent to <code>find({})</code>.</p>"},{"location":"tutorial/indexes/","title":"Indexes","text":""},{"location":"tutorial/indexes/#indexes-setup","title":"Indexes setup","text":"<p>There are more than one way to set up indexes using Beanie</p>"},{"location":"tutorial/indexes/#indexed-function","title":"Indexed function","text":"<p>To set up an index over a single field, the <code>Indexed</code> function can be used to wrap the type  and does not require a <code>Settings</code> class:</p> <pre><code>from bunnet import Document\nfrom bunnet import Indexed\n\n\nclass Sample(Document):\n    num: Indexed(int)\n    description: str\n</code></pre> <p>The <code>Indexed</code> function takes an optional <code>index_type</code> argument, which may be set to a pymongo index type:</p> <pre><code>import pymongo\n\nfrom bunnet import Document\nfrom bunnet import Indexed\n\n\nclass Sample(Document):\n    description: Indexed(str, index_type=pymongo.TEXT)\n</code></pre> <p>The <code>Indexed</code> function also supports PyMongo's <code>IndexModel</code> kwargs arguments (see the PyMongo Documentation for details). </p> <p>For example, to create a <code>unique</code> index:</p> <pre><code>from bunnet import Document\nfrom bunnet import Indexed\n\n\nclass Sample(Document):\n    name: Indexed(str, unique=True)\n</code></pre>"},{"location":"tutorial/indexes/#multi-field-indexes","title":"Multi-field indexes","text":"<p>The <code>indexes</code> field of the inner <code>Settings</code> class is responsible for more complex indexes.  It is a list where items can be:</p> <ul> <li>Single key. Name of the document's field (this is equivalent to using the Indexed function described above without any additional arguments)</li> <li>List of (key, direction) pairs. Key - string, name of the document's field. Direction - pymongo direction (   example: <code>pymongo.ASCENDING</code>)</li> <li><code>pymongo.IndexModel</code> instance - the most flexible   option. PyMongo Documentation</li> </ul> <pre><code>import pymongo\nfrom pymongo import IndexModel\n\nfrom bunnet import Document\n\n\nclass Sample(Document):\n    test_int: int\n    test_str: str\n\n    class Settings:\n        indexes = [\n            \"test_int\",\n            [\n                (\"test_int\", pymongo.ASCENDING),\n                (\"test_str\", pymongo.DESCENDING),\n            ],\n            IndexModel(\n                [(\"test_str\", pymongo.DESCENDING)],\n                name=\"test_string_index_DESCENDING\",\n            ),\n        ]\n</code></pre>"},{"location":"tutorial/inheritance/","title":"Inheritance","text":""},{"location":"tutorial/inheritance/#inheritance-for-multi-model-use-case","title":"Inheritance for multi-model use case","text":"<p>Bunnet <code>Documents</code> support inheritance as any other Python classes. But there are additional features available if you mark the root model with the parameter <code>is_root = True</code> in the inner Settings class.</p> <p>This behavior is similar to <code>UnionDoc</code>, but you don't need an additional entity. Parent <code>Document</code> act like a \"controller\", that handles proper storing and fetches different <code>Document</code> types. Also, parent <code>Document</code> can have some shared attributes which are propagated to all children. All classes in the inheritance chain can be used as <code>Link</code> in foreign <code>Documents</code>.</p> <p>Depending on the business logic, parent <code>Document</code> can be like an \"abstract\" class that is not used to store objects of its type (like in the example below), as well as can be a full-fledged entity, like its children.</p>"},{"location":"tutorial/inheritance/#defining-models","title":"Defining models","text":"<p>To set the root model you have to set <code>is_root = True</code> in the inner Settings class. All the inherited documents (on any level) will be stored in the same collection.</p> <pre><code>from typing import Optional, List\nfrom pydantic import BaseModel\nfrom pymongo import MongoClient\n\nfrom bunnet import Document, Link, init_bunnet\n\n\nclass Vehicle(Document):\n    \"\"\"Inheritance scheme bellow\"\"\"\n    #               Vehicle\n    #              /   |   \\\n    #             /    |    \\\n    #        Bicycle  Bike  Car\n    #                         \\\n    #                          \\\n    #                          Bus\n    # shared attribute for all children\n    color: str\n\n    class Settings:\n        is_root = True\n\n\nclass Fuelled(BaseModel):\n    \"\"\"Just a mixin\"\"\"\n    fuel: Optional[str]\n\n\nclass Bicycle(Vehicle):\n    \"\"\"Derived from Vehicle, will use its collection\"\"\"\n    frame: int\n    wheels: int\n\n\nclass Bike(Vehicle, Fuelled):\n    ...\n\n\nclass Car(Vehicle, Fuelled):\n    body: str\n\n\nclass Bus(Car, Fuelled):\n    \"\"\"Inheritance chain is Vehicle -&gt; Car -&gt; Bus, it is also stored in Vehicle collection\"\"\"\n    seats: int\n\n\nclass Owner(Document):\n    vehicles: Optional[List[Link[Vehicle]]]\n</code></pre>"},{"location":"tutorial/inheritance/#inserts","title":"Inserts","text":"<p>Inserts work the same way as usual</p> <pre><code>client = MongoClient()\ninit_bunnet(client.test_db, document_models=[Vehicle, Bicycle, Bike, Car, Bus])\n\nbike_1 = Bike(color='black', fuel='gasoline').insert()\n\ncar_1 = Car(color='grey', body='sedan', fuel='gasoline').insert()\ncar_2 = Car(color='white', body='crossover', fuel='diesel').insert()\n\nbus_1 = Bus(color='white', seats=80, body='bus', fuel='diesel').insert()\nbus_2 = Bus(color='yellow', seats=26, body='minibus', fuel='diesel').insert()\n\nowner = Owner(name='John', vehicles=[car_1, car_2, bus_1]).insert()\n</code></pre>"},{"location":"tutorial/inheritance/#find-operations","title":"Find operations","text":"<p>With parameter <code>with_children = True</code> the find query results will contain all the children classes' objects.</p> <pre><code># this query returns vehicles of all types that have white color, becuase `with_children` is True\nwhite_vehicles = Vehicle.find(Vehicle.color == 'white', with_children=True).to_list()\n# [\n#    Bicycle(..., color='white', frame=54, wheels=29),\n#    Car(fuel='diesel', ..., color='white', body='crossover'),\n#    Bus(fuel='diesel', ..., color='white', body='bus', seats=80)\n# ]\n</code></pre> <p>If the search is based on a child, the query returns this child type and all sub-children (with parameter <code>with_children=True</code>)</p> <pre><code>cars_and_buses = Car.find(Car.fuel == 'diesel', with_children=True).to_list()\n# [\n#     Car(fuel='diesel', ..., color='white', body='crossover'),\n#     Bus(fuel='diesel', ..., color='white', body='bus', seats=80),\n#     Bus(fuel='diesel', ..., color='yellow', body='minibus', seats=26)\n# ]\n</code></pre> <p>If you need to return objects of the specific class only, you can use this class for finding:</p> <pre><code># however it is possible to limit by Vehicle type\ncars_only = Car.find().to_list()\n# [\n#     Car(fuel='gasoline', ..., color='grey', body='sedan'),\n#     Car(fuel='diesel', ..., color='white', body='crossover')\n# ]\n</code></pre> <p>To get a single Document it is not necessary to know the type. You can query using the parent class</p> <pre><code>Vehicle.get(bus_2.id, with_children=True).run()\n# returns Bus instance:\n# Bus(fuel='diesel', ..., color='yellow', body='minibus', seats=26)\n</code></pre>"},{"location":"tutorial/inheritance/#relations","title":"Relations","text":"<p>Linked documents will be resolved into the respective classes</p> <pre><code>owner = Owner.get(owner.id, fetch_links=True).run()\n\nprint(owner.vehicles)\n# [\n#    Car(fuel='diesel', ..., color='white', body='crossover'),\n#    Bus(fuel='diesel', ..., color='white', body='bus', seats=80),\n#    Car(fuel='gasoline', ..., color='grey', body='sedan')\n# ]\n</code></pre> <p>The same result will be if the owner gets objects without fetching the links, and they will be fetched manually later</p>"},{"location":"tutorial/inheritance/#other","title":"Other","text":"<p>All other operations work the same way as for simple Documents</p> <pre><code>Bike.find().update({\"$set\": {Bike.color: 'yellow'}}).run()\nCar.find_one(Car.body == 'sedan').run()\n</code></pre>"},{"location":"tutorial/initialization/","title":"Initialization","text":"<p>Bunnet uses <code>PyMongo</code> as database engine for sync cases. To initialize previously created documents, you should provide a <code>PyMongo</code> database instance and a list of your document models to the <code>init_bunnet(...)</code> function, as it is shown in the example:</p> <pre><code>from bunnet import init_bunnet, Document\nfrom pymongo import MongoClient\n\nclass Sample(Document):\n    name: str\n\ndef init():\n    # Create PyMongo client\n    client = MongoClient(\n        \"mongodb://user:pass@host:27017\"\n    )\n\n    # Initialize bunnet with the Product document class and a database\n    init_bunnet(database=client.db_name, document_models=[Sample])\n</code></pre> <p>This creates the collection (if necessary) and sets up any indexes that are defined.</p> <p><code>init_bunnet</code> supports not only a list of classes as the document_models argument,  but also strings with dot-separated paths:</p> <pre><code>init_bunnet(\n    database=client.db_name,\n    document_models=[\n        \"app.models.DemoDocument\",\n    ],\n)\n</code></pre>"},{"location":"tutorial/initialization/#warning","title":"Warning","text":"<p><code>init_bunnet</code> supports the parameter named <code>allow_index_dropping</code> that will drop indexes from your collections.  <code>allow_index_dropping</code> is by default set to <code>False</code>. If you set this to <code>True</code>,  ensure that you are not managing your indexes in another manner.  If you are, these will be deleted when setting <code>allow_index_dropping=True</code>.</p>"},{"location":"tutorial/inserting-into-the-database/","title":"Insert the documents","text":"<p>Bunnet documents behave just like pydantic models (because they subclass <code>pydantic.BaseModel</code>). Hence, a document can be created in a similar fashion to pydantic:</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom bunnet import Document\nfrom bunnet import Indexed\n\n\nclass Category(BaseModel):\n    name: str\n    description: str\n\n\nclass Product(Document):  # This is the model\n    name: str\n    description: Optional[str] = None\n    price: Indexed(float)\n    category: Category\n\n    class Settings:\n        name = \"products\"\n\n\nchocolate = Category(name=\"Chocolate\", description=\"A preparation of roasted and ground cacao seeds.\")\ntonybar = Product(name=\"Tony's\", price=5.95, category=chocolate)\nmarsbar = Product(name=\"Mars\", price=1, category=chocolate)\n</code></pre> <p>This however does not save the documents to the database yet.</p>"},{"location":"tutorial/inserting-into-the-database/#insert-a-single-document","title":"Insert a single document","text":"<p>To insert a document into the database, you can call either <code>insert()</code> or <code>create()</code> on it (they are synonyms):</p> <p><pre><code>tonybar.insert()\nmarsbar.create()  # does exactly the same as insert()\n</code></pre> You can also call <code>save()</code>, which behaves in the same manner for new documents, but will also update existing documents.  See the section on updating of this tutorial for more details.</p> <p>If you prefer, you can also call the <code>insert_one</code> class method: </p> <pre><code>Product.insert_one(tonybar)\n</code></pre>"},{"location":"tutorial/inserting-into-the-database/#inserting-many-documents","title":"Inserting many documents","text":"<p>To reduce the number of database queries,  similarly typed documents should be inserted together by calling the class method <code>insert_many</code>:</p> <pre><code>Product.insert_many([tonybar,marsbar])\n</code></pre>"},{"location":"tutorial/lazy-parsing/","title":"Lazy parsing","text":""},{"location":"tutorial/lazy-parsing/#using-lazy-parsing-in-queries","title":"Using Lazy Parsing in Queries","text":"<p>Lazy parsing allows you to skip the parsing and validation process for documents and instead call it on demand for each field separately. This can be useful for optimizing performance in certain scenarios.</p> <p>To use lazy parsing in your queries, you can pass the <code>lazy_parse=True</code> parameter to your find method.</p> <p>Here's an example of how to use lazy parsing in a find query:</p> <pre><code>Sample.find(Sample.number == 10, lazy_parse=True).to_list()\n</code></pre> <p>By setting lazy_parse=True, the parsing and validation process will be skipped and be called on demand when the respective fields will be used. This can potentially improve the performance of your query by reducing the amount of processing required upfront. However, keep in mind that using lazy parsing may also introduce some additional overhead when accessing the fields later on.</p>"},{"location":"tutorial/migrate-from-beanie/","title":"Migrate from Beanie","text":""},{"location":"tutorial/migrate-from-beanie/#migrate-from-beanie","title":"Migrate from Beanie","text":"<p>Bunnet is a synchronous version of Beanie ODM. If you used Beanie before, migrating to Bunnet will be simple.</p> <p>It uses synchronous interfaces instead of Beanie's async interfaces. Nearly all the syntax is the same. But there are a few significant changes.</p>"},{"location":"tutorial/migrate-from-beanie/#import","title":"Import","text":"<pre><code>from bunnet import Document\n\nclass Product(Document):\n    name: str\n    price: float\n</code></pre>"},{"location":"tutorial/migrate-from-beanie/#init","title":"Init","text":"<p>As it is a synchronous version, a sync client should be used for the initialization.</p> <pre><code>from pymongo import MongoClient\n\nfrom bunnet import init_bunnet\n\n\ncli = MongoClient(\"mongodb://localhost:27017\")\ndb = cli.products_db\n\ninit_bunnet(database=db, document_models=[Product])\n</code></pre>"},{"location":"tutorial/migrate-from-beanie/#queries","title":"Queries","text":"<p>For query objects <code>FindOne</code>, <code>UpdateQuery</code>, and <code>DeleteQuery</code> you need to call the additional <code>run()</code> method at the end of the methods chain to fetch/commit. As a syntax sugar it can be replaced with <code>~</code> prefix.</p>"},{"location":"tutorial/migrate-from-beanie/#find","title":"Find","text":"<p>Get <pre><code>bar = Product.get(\"608da169eb9e17281f0ab2ff\").run()\n# or\nbar = ~Product.get(\"608da169eb9e17281f0ab2ff\")\n</code></pre></p> <p>Find one <pre><code>bar = Product.find_one(Product.name == \"Peanut Bar\").run()\n# or\nbar = ~Product.find_one(Product.name == \"Peanut Bar\")\n</code></pre></p> <p>For find many you don't need to call <code>run()</code> method, as it is iterator:</p> <pre><code>for result in Product.find(search_criteria):\n    print(result)\n\n# or\n\nresult = Product.find(search_criteria).to_list()\n</code></pre>"},{"location":"tutorial/migrate-from-beanie/#update","title":"Update","text":"<p>Update one <pre><code>Product.find_one(Product.name == \"Tony's\").update({\"$set\": {Product.price: 3.33}}).run()\n# or\n~Product.find_one(Product.name == \"Tony's\").update({\"$set\": {Product.price: 3.33}})\n</code></pre></p> <p>BTW update of the already fetched object works without calling the <code>run</code> method as it doesn't return <code>UpdateQuery</code> in result <pre><code>bar = Product.find_one(Product.name == \"Milka\").run()\nbar.update({\"$set\": {Product.price: 3.33}})\n</code></pre></p> <p>Update many <pre><code>Product.find(Product.price &lt;= 2).update({\"$set\": {Product.price: 3.33}}).run()\n# or\n~Product.find(Product.price &lt;= 2).update({\"$set\": {Product.price: 3.33}})\n</code></pre></p>"},{"location":"tutorial/migrate-from-beanie/#delete","title":"Delete","text":"<p>Single <pre><code>Product.find_one(Product.name == \"Milka\").delete().run()\n\n# or\n\n~Product.find_one(Product.name == \"Milka\").delete()\n\n# or\n\nbar = Product.find_one(Product.name == \"Milka\").run()\nbar.delete()\n</code></pre></p> <p>Many <pre><code>Product.find(Product.category.name == \"Chocolate\").delete().run()\n\n# or\n\n~Product.find(Product.category.name == \"Chocolate\").delete()\n</code></pre></p>"},{"location":"tutorial/migrations/","title":"Migrations","text":""},{"location":"tutorial/migrations/#attention","title":"Attention!","text":"<p>Migrations use transactions inside. They work only with MongoDB replica sets</p>"},{"location":"tutorial/migrations/#create","title":"Create","text":"<p>To create a new migration, run:</p> <pre><code>bunnet new-migration -n migration_name -p relative/path/to/migrations/directory/\n</code></pre> <p>It will create a file named <code>*_migration_name.py</code> in the directory <code>relative/path/to/migrations/directory/</code></p> <p>Migration file contains two classes: <code>Forward</code> and <code>Backward</code>.  Each one contains instructions to roll migration respectively forward and backward.</p>"},{"location":"tutorial/migrations/#run","title":"Run","text":"<p>To roll one forward migration, run:</p> <pre><code>bunnet migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --distance 1\n</code></pre> <p>To roll all forward migrations, run:</p> <pre><code>bunnet migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/\n</code></pre> <p>To roll one backward migration, run:</p> <pre><code>bunnet migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --distance 1 --backward\n</code></pre> <p>To roll all backward migrations, run:</p> <pre><code>bunnet migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --backward\n</code></pre> <p>To show the help message with all the parameters and descriptions, run:</p> <pre><code>bunnet migrate --help\n</code></pre>"},{"location":"tutorial/migrations/#migration-types","title":"Migration types","text":"<p>Migration class contains instructions - decorated functions. There are two types of instructions:</p> <ul> <li>Iterative migration - instruction that iterates over all the documents of the input_document collection and updates it. Most convenient to use, should be used in 99% cases.</li> <li>Free fall migrations - instruction where user can write any logic. Most flexible, but verbose.</li> </ul>"},{"location":"tutorial/migrations/#iterative-migrations","title":"Iterative migrations","text":"<p>To mark a function as iterative migration, <code>@iterative_migration()</code> decorator must be used.  The function itself must accept typed <code>input_document</code> and <code>output_document</code> arguments. Like here:</p> <pre><code>@iterative_migration()\ndef name_to_title(\n        self, input_document: OldNote, output_document: Note\n):\n</code></pre>"},{"location":"tutorial/migrations/#a-simple-example-of-field-name-changing","title":"A simple example of field name changing","text":"<p>There are the next models:</p> <pre><code>class Tag(BaseModel):\n    color: str\n    name: str\n\n\nclass OldNote(Document):\n    name: str\n    tag: Tag\n\n    class Settings:\n        name = \"notes\"\n\n\nclass Note(Document):\n    title: str\n    tag: Tag\n\n    class Settings:\n        name = \"notes\"\n</code></pre> <p>To migrate from <code>OldNote</code> to <code>Note</code>, file <code>name</code> has to be renamed to <code>title</code>.</p> <p>Forward migration:</p> <pre><code>class Forward:\n    @iterative_migration()\n    def name_to_title(\n            self, input_document: OldNote, output_document: Note\n    ):\n        output_document.title = input_document.name\n</code></pre> <p>Backward migration:</p> <pre><code>class Backward:\n    @iterative_migration()\n    def title_to_name(\n            self, input_document: Note, output_document: OldNote\n    ):\n        output_document.name = input_document.title\n</code></pre> <p>And a little more complex example:</p> <p><pre><code>from pydantic.main import BaseModel\n\nfrom bunnet import Document, iterative_migration\n\n\nclass OldTag(BaseModel):\n    color: str\n    name: str\n\n\nclass Tag(BaseModel):\n    color: str\n    title: str\n\n\nclass OldNote(Document):\n    title: str\n    tag: OldTag\n\n    class Settings:\n        name = \"notes\"\n\n\nclass Note(Document):\n    title: str\n    tag: Tag\n\n    class Settings:\n        name = \"notes\"\n\n\nclass Forward:\n    @iterative_migration()\n    def change_color(\n            self, input_document: OldNote, output_document: Note\n    ):\n        output_document.tag.title = input_document.tag.name\n\n\nclass Backward:\n    @iterative_migration()\n    def change_title(\n            self, input_document: Note, output_document: OldNote\n    ):\n        output_document.tag.name = input_document.tag.title\n</code></pre> All the examples of migrations can be found by link</p>"},{"location":"tutorial/migrations/#free-fall-migrations","title":"Free fall migrations","text":"<p>It is a much more flexible migration type, which allows the implementation of any migration logic.  But at the same time, it is more verbose.</p> <p>To mark function as a free fall migration,  <code>@free_fall_migration()</code> decorator with the list of Document classes must be used.  Function itself accepts <code>session</code> as an argument.  It is used in order to roll back the migration in case something has gone wrong.  To be able to roll back, please pass session to the Documents methods. Like here:</p> <pre><code>@free_fall_migration(document_models=[OldNote, Note])\ndef name_to_title(self, session):\n    for old_note in OldNote.find_all():\n        new_note = Note(\n            id=old_note.id, title=old_note.name, tag=old_note.tag\n        )\n        new_note.replace(session=session)\n</code></pre>"},{"location":"tutorial/migrations/#the-same-example-as-for-the-iterative-migration-but-with-free-fall-migration-type","title":"The same example as for the iterative migration, but with free fall migration type","text":"<p><pre><code>from pydantic.main import BaseModel\n\nfrom bunnet import Document, free_fall_migration\n\n\nclass Tag(BaseModel):\n    color: str\n    name: str\n\n\nclass OldNote(Document):\n    name: str\n    tag: Tag\n\n    class Settings:\n        name = \"notes\"\n\n\nclass Note(Document):\n    title: str\n    tag: Tag\n\n    class Settings:\n        name = \"notes\"\n\n\nclass Forward:\n    @free_fall_migration(document_models=[OldNote, Note])\n    def name_to_title(self, session):\n        for old_note in OldNote.find_all():\n            new_note = Note(\n                id=old_note.id, title=old_note.name, tag=old_note.tag\n            )\n            new_note.replace(session=session)\n\n\nclass Backward:\n    @free_fall_migration(document_models=[OldNote, Note])\n    def title_to_name(self, session):\n        for old_note in Note.find_all():\n            new_note = OldNote(\n                id=old_note.id, name=old_note.title, tag=old_note.tag\n            )\n            new_note.replace(session=session)\n</code></pre> All the examples of migrations can be found by link</p>"},{"location":"tutorial/multi-model-pattern/","title":"Multi-model pattern","text":"<p>Documents with different schemas could be stored in a single collection and managed correctly.  <code>UnionDoc</code> class is used for this.</p> <p>It supports <code>find</code> and <code>aggregate</code> methods.  For <code>find</code>, it will fetch all the found documents into the respective <code>Document</code> classes.</p> <p>Documents that have <code>union_doc</code> in their settings can still be used in <code>find</code> and other queries.  Queries of one such class will not see the data of others.</p>"},{"location":"tutorial/multi-model-pattern/#example","title":"Example","text":"<p>Create documents:</p> <pre><code>from bunnet import Document, UnionDoc\n\n\nclass Parent(UnionDoc):  # Union\n    class Settings:\n        name = \"union_doc_collection\"  # Collection name\n        class_id = \"_class_id\"  # _class_id is default beanie internal field used to filter children Documents\n\n\nclass One(Document):\n    int_field: int = 0\n    shared: int = 0        \n\n    class Settings:\n        name = \"One\" # Name used to filer union document 'One', default to class name\n        union_doc = Parent\n\n\nclass Two(Document):\n    str_field: str = \"test\"\n    shared: int = 0\n\n    class Settings:\n        union_doc = Parent\n</code></pre> <p>The schemas could be incompatible.</p> <p>Insert a document</p> <pre><code>One().insert()\nOne().insert()\nOne().insert()\n\nTwo().insert()\n</code></pre> <p>Find all the documents of the first type:</p> <pre><code>docs = One.all().to_list()\nprint(len(docs))\n\n&gt;&gt; 3 # It found only documents of class One\n</code></pre> <p>Of the second type:</p> <pre><code>docs = Two.all().to_list()\nprint(len(docs))\n\n&gt;&gt; 1 # It found only documents of class One\n</code></pre> <p>Of both:</p> <pre><code>docs = Parent.all().to_list()\nprint(len(docs))\n\n&gt;&gt; 4 # instances of the both classes will be in the output here\n</code></pre> <p>Aggregations will work separately for these two document classes too.</p>"},{"location":"tutorial/on-save-validation/","title":"On save validation","text":"<p>Pydantic has a very useful config to validate values on assignment - <code>validate_assignment = True</code>.  But, unfortunately, this is an expensive operation and doesn't fit some use cases. You can validate all the values before saving the document (<code>insert</code>, <code>replace</code>, <code>save</code>, <code>save_changes</code>)  with bunnet config <code>validate_on_save</code> instead.</p> <p>This feature must be turned on in the <code>Settings</code> inner class explicitly:</p> <pre><code>from bunnet import Document\n\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    class Settings:\n        validate_on_save = True\n</code></pre> <p>If any field has a wrong value,  it will raise an error on write operations (<code>insert</code>, <code>replace</code>, <code>save</code>, <code>save_changes</code>).</p> <pre><code>sample = Sample.find_one(Sample.name == \"Test\").run()\nsample.num = \"wrong value type\"\n\n# Next call will raise an error\nsample.replace()\n</code></pre>"},{"location":"tutorial/relations/","title":"Relations","text":"<p>The document can contain links to other documents in their fields.</p> <p>Only top-level fields are fully supported for now.</p> <p>The following field types are supported:</p> <ul> <li><code>Link[...]</code></li> <li><code>Optional[Link[...]]</code></li> <li><code>List[Link[...]]</code></li> <li><code>Optional[List[Link[...]]]</code></li> </ul> <p>Also, backward links are supported:</p> <ul> <li><code>BackLink[...]</code></li> <li><code>Optional[BackLink[...]]</code></li> <li><code>List[BackLink[...]]</code></li> <li><code>Optional[List[BackLink[...]]]</code></li> </ul> <p>Direct link to the document:</p> <pre><code>from bunnet import Document, Link\n\n\nclass Door(Document):\n    height: int = 2\n    width: int = 1\n\n\nclass House(Document):\n    name: str\n    door: Link[Door]\n</code></pre> <p>Optional direct link to the document:</p> <pre><code>from typing import Optional\n\nfrom bunnet import Document, Link\n\n\nclass Door(Document):\n    height: int = 2\n    width: int = 1\n\n\nclass House(Document):\n    name: str\n    door: Optional[Link[Door]]\n</code></pre> <p>List of the links:</p> <pre><code>from typing import List\n\nfrom bunnet import Document, Link\n\n\nclass Window(Document):\n    x: int = 10\n    y: int = 10\n\n\nclass House(Document):\n    name: str\n    door: Link[Door]\n    windows: List[Link[Window]]\n</code></pre> <p>Optional list of the links:</p> <pre><code>from typing import List, Optional\n\nfrom bunnet import Document, Link\n\nclass Window(Document):\n    x: int = 10\n    y: int = 10\n\nclass Yard(Document):\n    v: int = 10\n    y: int = 10\n\nclass House(Document):\n    name: str\n    door: Link[Door]\n    windows: List[Link[Window]]\n    yards: Optional[List[Link[Yard]]]\n</code></pre> <p>Other link patterns are not supported at this moment. If you need something more specific for your use-case,  please open an issue on the GitHub page - https://github.com/roman-right/bunnet</p>"},{"location":"tutorial/relations/#write","title":"Write","text":"<p>The following write methods support relations:</p> <ul> <li><code>insert(...)</code></li> <li><code>replace(...)</code></li> <li><code>save(...)</code></li> </ul> <p>To apply a write method to the linked documents, you should pass the respective <code>link_rule</code> argument</p> <pre><code>house.windows = [Window(x=100, y=100)]\nhouse.name = \"NEW NAME\"\n\n# The next call will insert a new window object and replace the house instance with updated data\nhouse.save(link_rule=WriteRules.WRITE)\n\n# `insert` and `replace` methods will work the same way\n</code></pre> <p>Otherwise, Bunnet can ignore internal links with the <code>link_rule</code> parameter <code>WriteRules.DO_NOTHING</code></p> <pre><code>house.door.height = 3\nhouse.name = \"NEW NAME\"\n\n# The next call will just replace the house instance with new data, but the linked door object will not be synced\nhouse.replace(link_rule=WriteRules.DO_NOTHING)\n\n# `insert` and `save` methods will work the same way\n</code></pre>"},{"location":"tutorial/relations/#fetch","title":"Fetch","text":""},{"location":"tutorial/relations/#prefetch","title":"Prefetch","text":"<p>You can fetch linked documents on the find query step using the <code>fetch_links</code> parameter </p> <p><pre><code>houses = House.find(\n    House.name == \"test\", \n    fetch_links=True\n).to_list()\n</code></pre> Supported find methods: - <code>find</code> - <code>find_one</code> - <code>get</code></p> <p>Bunnet uses the single aggregation query under the hood to fetch all the linked documents.  This operation is very effective.</p> <p>If a direct link is referred to a non-existent document,  after fetching it will remain the object of the <code>Link</code> class.</p> <p>Fetching will ignore non-existent documents for the list of links fields.</p>"},{"location":"tutorial/relations/#search-by-linked-documents-fields","title":"Search by linked documents fields","text":"<p>If the <code>fetch_links</code> parameter is set to <code>True</code>, search by linked documents fields is available.</p> <p>By field of the direct link:</p> <pre><code>houses = House.find(\n    House.door.height == 2,\n    fetch_links=True\n).to_list()\n</code></pre> <p>By list of links:</p> <pre><code>houses = House.find(\n    House.windows.x &gt; 10,\n    fetch_links=True\n).to_list()\n</code></pre> <p>Search by <code>id</code> of the linked documents works using the following syntax:</p> <pre><code>houses = House.find(\n    House.door.id == \"DOOR_ID_HERE\"\n).to_list()\n</code></pre> <p>It works the same way with <code>fetch_links</code> equal to <code>True</code> and <code>False</code> and for <code>find_many</code> and <code>find_one</code> methods.</p>"},{"location":"tutorial/relations/#on-demand-fetch","title":"On-demand fetch","text":"<p>If you don't use prefetching, linked documents will be presented as objects of the <code>Link</code> class.  You can fetch them manually afterwards. To fetch all the linked documents, you can use the <code>fetch_all_links</code> method</p> <pre><code>house.fetch_all_links()\n</code></pre> <p>It will fetch all the linked documents and replace <code>Link</code> objects with them.</p> <p>Otherwise, you can fetch a single field:</p> <pre><code>house.fetch_link(House.door)\n</code></pre> <p>This will fetch the Door object and put it into the <code>door</code> field of the <code>house</code> object.</p>"},{"location":"tutorial/relations/#delete","title":"Delete","text":"<p>Delete method works the same way as write operations, but it uses other rules.</p> <p>To delete all the links on the document deletion,  you should use the <code>DeleteRules.DELETE_LINKS</code> value for the <code>link_rule</code> parameter:</p> <pre><code>house.delete(link_rule=DeleteRules.DELETE_LINKS).run()\n</code></pre> <p>To keep linked documents, you can use the <code>DO_NOTHING</code> rule:</p> <pre><code>house.delete(link_rule=DeleteRules.DO_NOTHING).run()\n</code></pre>"},{"location":"tutorial/relations/#back-links","title":"Back Links","text":"<p>To init the back link you should have a document with the direct or list of links to the current document.</p> <pre><code>from typing import List\n\nfrom bunnet import Document, BackLink, Link\nfrom pydantic import Field\n\n\nclass House(Document):\n    name: str\n    door: Link[\"Door\"]\n    owners: List[Link[\"Person\"]]\n\n\nclass Door(Document):\n    height: int = 2\n    width: int = 1\n    house: BackLink[House] = Field(original_field=\"door\")\n\n\nclass Person(Document):\n    name: str\n    house: List[BackLink[House]] = Field(original_field=\"owners\")\n</code></pre> <p>The <code>original_field</code> parameter is required for the back link field.</p> <p>Back links support all the operations that normal links support.</p>"},{"location":"tutorial/relations/#limitations","title":"Limitations","text":"<ul> <li>Find operations with the <code>fetch_links</code> parameter can not be used in the chaning with <code>delete</code> and <code>update</code> methods.</li> </ul>"},{"location":"tutorial/revision/","title":"Revision","text":"<p>This feature helps with concurrent operations.  It stores <code>revision_id</code> together with the document and changes it on each document update.  If the application with an older local copy of the document tries to change it, an exception will be raised.  Only when the local copy is synced with the database, the application will be allowed to change the data.  This helps to avoid data losses.</p>"},{"location":"tutorial/revision/#be-aware","title":"Be aware","text":"<p>revision id feature may work incorrectly with BulkWriter.</p>"},{"location":"tutorial/revision/#usage","title":"Usage","text":"<p>This feature must be explicitly turned on in the <code>Settings</code> inner class:</p> <pre><code>from bunnet import Document\n\n\nclass Sample(Document):\n    num: int\n    name: str\n\n    class Settings:\n        use_revision = True\n</code></pre> <p>Any changing operation will check if the local copy of the document has the up-to-date <code>revision_id</code> value:</p> <pre><code>s = Sample.find_one(Sample.name=\"TestName\").run()\ns.num = 10\n\n# If a concurrent process already changed the doc, the next operation will raise an error\ns.replace()\n</code></pre> <p>If you want to ignore revision and apply all the changes even if the local copy is outdated,  you can use the <code>ignore_revision</code> parameter:</p> <pre><code>s.replace(ignore_revision=True)\n</code></pre>"},{"location":"tutorial/state-management/","title":"State Management","text":"<p>Bunnet can keep the document state synced with the database in order to find local changes and save only them.</p> <p>This feature must be explicitly turned on in the <code>Settings</code> inner class:</p> <pre><code>class Sample(Document):\n    num: int\n    name: str\n\n    class Settings:\n        use_state_management = True\n</code></pre> <p>Beanie keeps the current changes (not yet saved in the database) by default (with <code>use_state_management = True</code>), AND the previous changes (saved to the database) with <code>state_management_save_previous = True</code>.</p> <pre><code>class Sample(Document):\n    num: int\n    name: str\n\n    class Settings:\n        use_state_management = True\n        state_management_save_previous = True\n</code></pre> <p>Every new save override the previous changes and clears the current changes.</p>"},{"location":"tutorial/state-management/#saving-changes","title":"Saving changes","text":"<p>To save only changed values, the <code>save_changes()</code> method should be used.</p> <pre><code>s = Sample.find_one(Sample.name == \"Test\").run()\ns.num = 100\ns.save_changes()\n</code></pre> <p>The <code>save_changes()</code> method can only be used with already inserted documents.</p>"},{"location":"tutorial/state-management/#interacting-with-changes","title":"Interacting with changes","text":"<p>Beanie exposes several methods that can be used to interact with the saved changes:</p> <pre><code>s = Sample.find_one(Sample.name == \"Test\").run()\n\ns.is_changed == False\ns.get_changes == {}\n\ns.num = 200\n\ns.is_changed == True\ns.get_changes() == {\"num\": 200}\n\ns.rollback()\n\ns.is_changed == False\ns.get_changes() == {}\n</code></pre> <p>And similar methods can be used with the previous changes that have been saved in the database if <code>state_management_save_previous</code> is set to <code>True</code>:</p> <pre><code>s = Sample.find_one(Sample.name == \"Test\").run()\n\ns.num = 200\ns.save_changes()\n\ns.has_changed == True\ns.get_previous_changes() == {\"num\": 200}\ns.get_changes() == {}\n</code></pre> <p>The <code>save_changes()</code> method can be used only with already existing documents.</p>"},{"location":"tutorial/state-management/#options","title":"Options","text":"<p>By default, state management will merge the changes made to nested objects,  which is fine for most cases as it is non-destructive and does not re-assign the whole object  if only one of its attributes changed:</p> <pre><code>from typing import Dict\n\n\nclass Item(Document):\n    name: str\n    attributes: Dict[str, float]\n\n    class Settings:\n        use_state_management = True\n</code></pre> <pre><code>i = Item(name=\"Test\", attributes={\"attribute_1\": 1.0, \"attribute_2\": 2.0})\ni.insert()\ni.attributes = {\"attribute_1\": 1.0}\ni.save_changes()\n# Changes will consist of: {\"attributes.attribute_1\": 1.0}\n# Keeping attribute_2\n</code></pre> <p>However, there are some cases where you would want to replace the whole object when one of its attributes changed. You can enable the <code>state_management_replace_objects</code> attribute in your model's <code>Settings</code> inner class:</p> <pre><code>from typing import Dict\n\n\nclass Item(Document):\n    name: str\n    attributes: Dict[str, float]\n\n    class Settings:\n        use_state_management = True\n        state_management_replace_objects = True\n</code></pre> <p>With this setting activated, the whole object will be overridden when one attribute of the nested object is changed:</p> <pre><code>i = Item(name=\"Test\", attributes={\"attribute_1\": 1.0, \"attribute_2\": 2.0})\ni.insert()\ni.attributes.attribute_1 = 1.0\ni.save_changes()\n# Changes will consist of: {\"attributes.attribute_1\": 1.0, \"attributes.attribute_2\": 2.0}\n# Keeping attribute_2\n</code></pre> <p>When the whole object is assigned, the whole nested object will be overridden:</p> <pre><code>i = Item(name=\"Test\", attributes={\"attribute_1\": 1.0, \"attribute_2\": 2.0})\ni.insert()\ni.attributes = {\"attribute_1\": 1.0}\ni.save_changes()\n# Changes will consist of: {\"attributes\": {\"attribute_1\": 1.0}}\n# Removing attribute_2\n</code></pre>"},{"location":"tutorial/time-series/","title":"Time Series","text":""},{"location":"tutorial/time-series/#time-series","title":"Time series","text":"<p>You can set up a timeseries collection using the inner <code>Settings</code> class.</p> <p>Be aware, timeseries collections a supported by MongoDB 5.0 and higher only.</p> <pre><code>from datetime import datetime\n\nfrom bunnet import Document, TimeSeriesConfig, Granularity\nfrom pydantic import Field\n\n\nclass Sample(Document):\n    ts: datetime = Field(default_factory=datetime.now)\n    meta: str\n\n    class Settings:\n        timeseries = TimeSeriesConfig(\n            time_field=\"ts\", #  Required\n            meta_field=\"meta\", #  Optional\n            granularity=Granularity.hours, #  Optional\n            expire_after_seconds=2  #  Optional\n        )\n</code></pre> <p>TimeSeriesConfig fields reflect the respective parameters of the MongoDB timeseries creation function.</p> <p>MongoDB documentation: https://docs.mongodb.com/manual/core/timeseries-collections/</p>"},{"location":"tutorial/updating-%26-deleting/","title":"Updating &amp; Deleting","text":"<p>Now that we know how to find documents, how do we change them or delete them?</p>"},{"location":"tutorial/updating-%26-deleting/#saving-changes-to-existing-documents","title":"Saving changes to existing documents","text":"<p>The easiest way to change a document in the database is to use either the <code>replace</code> or <code>save</code> method on an altered document.  These methods both write the document to the database,  but <code>replace</code> will raise an exception when the document does not exist yet, while <code>save</code> will insert the document. </p> <p>Using <code>save()</code> method:</p> <pre><code>bar = Product.find_one(Product.name == \"Mars\").run()\nbar.price = 10\nbar.save()\n</code></pre> <p>Otherwise, use the <code>replace()</code> method, which throws: - a <code>ValueError</code> if the document does not have an <code>id</code> yet, or - a <code>bunnet.exceptions.DocumentNotFound</code> if it does, but the <code>id</code> is not present in the collection</p> <pre><code>bar.price = 10\ntry:\n    bar.replace()\nexcept (ValueError, bunnet.exceptions.DocumentNotFound):\n    print(\"Can't replace a non existing document\")\n</code></pre> <p>Note that these methods require multiple queries to the database and replace the entire document with the new version.  A more tailored solution can often be created by applying update queries directly on the database level.</p>"},{"location":"tutorial/updating-%26-deleting/#update-queries","title":"Update queries","text":"<p>Update queries can be performed on the result of a <code>find</code> or <code>find_one</code> query,  or on a document that was returned from an earlier query.  Simpler updates can be performed using the <code>set</code>, <code>inc</code>, and <code>current_date</code> methods:</p> <pre><code>bar = Product.find_one(Product.name == \"Mars\").run()\nbar.set({Product.name:\"Gold bar\"})\nbar = Product.find_all(Product.price &gt; .5).inc({Product.price: 1}).run()\n</code></pre> <p>More complex update operations can be performed by calling <code>update()</code> with an update operator, similar to find queries:</p> <pre><code>Product.find_one(Product.name == \"Tony's\").update(Set({Product.price: 3.33})).run()\n</code></pre> <p>The whole list of the update query operators can be found here.</p> <p>Native MongoDB syntax is also supported:</p> <pre><code>Product.find_one(Product.name == \"Tony's\").update({\"$set\": {Product.price: 3.33}}).run()\n</code></pre>"},{"location":"tutorial/updating-%26-deleting/#upsert","title":"Upsert","text":"<p>To insert a document when no documents are matched against the search criteria, the <code>upsert</code> method can be used:</p> <pre><code>Product.find_one(Product.name == \"Tony's\").upsert(\n    Set({Product.price: 3.33}), \n    on_insert=Product(name=\"Tony's\", price=3.33, category=chocolate)\n)\n</code></pre>"},{"location":"tutorial/updating-%26-deleting/#deleting-documents","title":"Deleting documents","text":"<p>Deleting objects works just like updating them, you simply call <code>delete()</code> on the found documents:</p> <pre><code>bar = Product.find_one(Product.name == \"Milka\").run()\nbar.delete()\n\nProduct.find_one(Product.name == \"Milka\").delete().run()\n\nProduct.find(Product.category.name == \"Chocolate\").delete().run()\n</code></pre>"},{"location":"tutorial/updating-%26-deleting/#response-type","title":"Response Type","text":"<p>For the object methods <code>update</code> and <code>upsert</code>, you can use the <code>response_type</code> parameter to specify the type of response.</p> <p>The options are: - <code>UpdateResponse.UPDATE_RESULT</code> - returns the result of the update operation. - <code>UpdateResponse.NEW_DOCUMENT</code> - returns the newly updated document. - <code>UpdateResponse.OLD_DOCUMENT</code> - returns the document before the update.</p>"},{"location":"tutorial/views/","title":"Views","text":"<p>Virtual views are aggregation pipelines stored in MongoDB that act as collections for reading operations. You can use the <code>View</code> class the same way as <code>Document</code> for <code>find</code> and <code>aggregate</code> operations.</p>"},{"location":"tutorial/views/#here-are-some-examples","title":"Here are some examples.","text":"<p>Create a view:</p> <pre><code>from pydantic import Field\n\nfrom bunnet import Document, View\n\n\nclass Bike(Document):\n    type: str\n    frame_size: int\n    is_new: bool\n\n\nclass Metrics(View):\n    type: str = Field(alias=\"_id\")\n    number: int\n    new: int\n\n    class Settings:\n        source = Bike\n        pipeline = [\n            {\n                \"$group\": {\n                    \"_id\": \"$type\",\n                    \"number\": {\"$sum\": 1},\n                    \"new\": {\"$sum\": {\"$cond\": [\"$is_new\", 1, 0]}}\n                }\n            },\n        ]\n</code></pre> <p>Initialize Bunnet:</p> <pre><code>from pymongo import MongoClient\nfrom bunnet import init_bunnet\n\n\ndef main():\n    uri = \"mongodb://bunnet:bunnet@localhost:27017\"\n    client = MongoClient(uri)\n    db = client.bikes\n\n    init_bunnet(\n        database=db, \n        document_models=[Bike, Metrics],\n        recreate_views=True,\n    )\n</code></pre> <p>Create bikes:</p> <pre><code>Bike(type=\"Mountain\", frame_size=54, is_new=True).insert()\nBike(type=\"Mountain\", frame_size=60, is_new=False).insert()\nBike(type=\"Road\", frame_size=52, is_new=True).insert()\nBike(type=\"Road\", frame_size=54, is_new=True).insert()\nBike(type=\"Road\", frame_size=58, is_new=False).insert()\n</code></pre> <p>Find metrics for <code>type == \"Road\"</code></p> <pre><code>results = Metrics.find(Metrics.type == \"Road\").to_list()\nprint(results)\n\n&gt;&gt; [Metrics(type='Road', number=3, new=2)]\n</code></pre> <p>Aggregate over metrics to get the count of all the new bikes:</p> <pre><code>results = Metrics.aggregate([{\n    \"$group\": {\n        \"_id\": None,\n        \"new_total\": {\"$sum\": \"$new\"}\n    }\n}]).to_list()\n\nprint(results)\n\n&gt;&gt; [{'_id': None, 'new_total': 3}]\n</code></pre> <p>A better result can be achieved by using find query aggregation syntactic sugar:</p> <pre><code>results = Metrics.all().sum(Metrics.new)\n\nprint(results)\n\n&gt;&gt; 3\n</code></pre>"}]}